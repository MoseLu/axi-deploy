name: Deploy Project

on:
  workflow_call:
    inputs:
      project:
        required: true
        type: string
        description: "项目名称"
      source_repo:
        required: true
        type: string
        description: "源仓库 (owner/repo)"
      run_id:
        required: true
        type: string
        description: "构建运行ID"
      deploy_type:
        required: true
        type: string
        description: "部署类型 (backend/static)"
        default: "static"
      server_host:
        required: true
        type: string
        description: "服务器地址"
      server_user:
        required: true
        type: string
        description: "服务器用户"
      server_key:
        required: true
        type: string
        description: "服务器密钥"
      server_port:
        required: true
        type: string
        description: "服务器端口"
      deploy_center_pat:
        required: false
        type: string
        description: "GitHub Token用于下载构建产物（可选，默认使用GITHUB_TOKEN）"
      apps_root:
        required: false
        type: string
        description: "应用目录路径"
        default: "/srv/apps"
      static_root:
        required: false
        type: string
        description: "静态文件目录路径"
        default: "/srv/static"
      backup_root:
        required: false
        type: string
        description: "备份根目录"
        default: "/srv/backups"
      run_user:
        required: false
        type: string
        description: "运行用户"
        default: "deploy"

    outputs:
      deploy_success:
        description: "部署是否成功"
        value: ${{ jobs.deploy.outputs.deploy_success }}
      deploy_path:
        description: "部署路径"
        value: ${{ jobs.deploy.outputs.deploy_path }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 20  # 部署超时时间
    permissions:
      contents: read
      actions: read
      packages: read
    outputs:
      deploy_success: ${{ steps.set-outputs.outputs.deploy_success }}
      deploy_path: ${{ steps.set-outputs.outputs.deploy_path }}
    
    steps:
      - name: 验证输入参数
        run: |
          echo "🔍 验证输入参数..."
          echo "- 项目: ${{ inputs.project }}"
          echo "- 源仓库: ${{ inputs.source_repo }}"
          echo "- 运行ID: ${{ inputs.run_id }}"
          echo "- 部署类型: ${{ inputs.deploy_type }}"
          echo "- 服务器: ${{ inputs.server_host }}:${{ inputs.server_port }}"
          echo "- 重试机制: 自动启用（最多重试2次）"
          
          # 记录部署开始时间
          echo "DEPLOY_START_TIME=$(date +%s)" >> $GITHUB_ENV
          echo "🚀 部署开始时间: $(date)"
          
          # 发送部署开始通知到WebSocket
          echo "📤 发送部署开始通知..."
          NOTIFICATION_DATA=$(cat <<EOF
          {
            "type": "step_started",
            "project": "${{ inputs.project }}",
            "deployment_id": "${{ inputs.run_id }}",
            "step_name": "部署验证",
            "step_status": "started",
            "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%S.000Z")",
            "workflow_name": "deploy-project",
            "workflow_id": "${{ github.run_id }}",
            "logs": "开始验证部署参数",
            "duration": 0
          }
          EOF
          )
          
          curl -s -X POST \
            -H "Content-Type: application/json" \
            -H "User-Agent: axi-deploy-websocket/1.0" \
            -d "$NOTIFICATION_DATA" \
            "https://redamancy.com.cn/project-dashboard/api/webhooks/deployment" || echo "⚠️ WebSocket通知发送失败"
          
          # 验证部署类型
          DEPLOY_TYPE="${{ inputs.deploy_type }}"
          if [ "$DEPLOY_TYPE" != "backend" ] && [ "$DEPLOY_TYPE" != "static" ]; then
            echo "❌ 无效的部署类型: $DEPLOY_TYPE"
            exit 1
          fi
          
          # 验证服务器参数
          SERVER_HOST="${{ inputs.server_host }}"
          SERVER_USER="${{ inputs.server_user }}"
          SERVER_PORT="${{ inputs.server_port }}"
          
          if [ -z "$SERVER_HOST" ]; then
            echo "❌ 服务器主机地址为空"
            exit 1
          fi
          if [ -z "$SERVER_USER" ]; then
            echo "❌ 服务器用户名为空"
            exit 1
          fi
          if [ -z "$SERVER_PORT" ]; then
            echo "❌ 服务器端口为空"
            exit 1
          fi
          
          echo "🔍 服务器参数验证:"
          echo "- 主机: $SERVER_HOST"
          echo "- 用户: $SERVER_USER"
          echo "- 端口: $SERVER_PORT"
          
          echo "✅ 输入参数验证通过"

      - name: 调试运行ID
        run: |
          echo "🔍 调试运行ID..."
          echo "接收到的运行ID: '${{ inputs.run_id }}'"
          echo "运行ID长度: $(echo '${{ inputs.run_id }}' | wc -c)"
          echo "运行ID是否为空: ${{ inputs.run_id == '' && '是' || '否' }}"
          
          if [ -z "${{ inputs.run_id }}" ]; then
            echo "🚨 运行ID为空，这可能是问题所在"
            exit 1
          fi
          
          echo "✅ 运行ID验证通过"

      - name: 调试下载参数
        run: |
          echo "🔍 调试下载参数..."
          echo "构建产物名称: dist-${{ inputs.project }}"
          echo "源仓库: ${{ inputs.source_repo }}"
          echo "运行ID: ${{ inputs.run_id }}"
          
          # 确定使用的Token
          if [ -n "${{ inputs.deploy_center_pat }}" ] && [ "${{ inputs.deploy_center_pat }}" != "null" ]; then
            USED_TOKEN="${{ inputs.deploy_center_pat }}"
            TOKEN_SOURCE="外部提供的PAT"
          else
            USED_TOKEN="${{ github.token }}"
            TOKEN_SOURCE="内置GITHUB_TOKEN"
          fi
          
          echo "🔍 Token调试信息:"
          echo "Token来源: $TOKEN_SOURCE"
          echo "Token长度: $(echo '$USED_TOKEN' | wc -c)"
          echo "Token是否为空: $([ -z "$USED_TOKEN" ] && echo '是' || echo '否')"
          echo "Token前10个字符: ${USED_TOKEN:0:10}..."
          
          echo "✅ 将使用Token: $TOKEN_SOURCE"

      - name: 测试PAT权限
        run: |
          echo "🔍 测试Token权限..."
          
          # 确定使用的Token
          if [ -n "${{ inputs.deploy_center_pat }}" ] && [ "${{ inputs.deploy_center_pat }}" != "null" ]; then
            USED_TOKEN="${{ inputs.deploy_center_pat }}"
            TOKEN_SOURCE="外部提供的PAT"
          else
            USED_TOKEN="${{ github.token }}"
            TOKEN_SOURCE="内置GITHUB_TOKEN"
          fi
          
          echo "🔍 使用Token来源: $TOKEN_SOURCE"
          
          # 测试Token是否有效
          RESPONSE=$(curl -s -H "Authorization: token $USED_TOKEN" \
            "https://api.github.com/user" 2>/dev/null || echo "API调用失败")
          
          if echo "$RESPONSE" | grep -q '"login"'; then
            USER_LOGIN=$(echo "$RESPONSE" | jq -r '.login // empty' 2>/dev/null)
            echo "✅ Token有效，用户: $USER_LOGIN"
          else
            echo "⚠️ Token权限测试失败，但继续尝试下载构建产物"
            echo "API响应: $RESPONSE"
            echo "🔍 这可能是正常的，因为内置Token可能无法访问用户信息，但仍可以下载构建产物"
          fi
          
          # 测试对目标仓库的访问权限
          REPO_RESPONSE=$(curl -s -H "Authorization: token $USED_TOKEN" \
            "https://api.github.com/repos/${{ inputs.source_repo }}" 2>/dev/null || echo "API调用失败")
          
          if echo "$REPO_RESPONSE" | grep -q '"name"'; then
            REPO_NAME=$(echo "$REPO_RESPONSE" | jq -r '.name // empty' 2>/dev/null)
            echo "✅ 可以访问仓库: $REPO_NAME"
          else
            echo "⚠️ 仓库访问测试失败，但继续尝试下载构建产物"
            echo "API响应: $REPO_RESPONSE"
            echo "🔍 这可能是正常的，因为内置Token可能无法访问某些仓库信息，但仍可以下载构建产物"
          fi
          
          echo "✅ Token权限测试完成，继续下载构建产物"

      - name: 下载构建产物
        run: |
          # 彻底清理旧文件和目录
          echo "🧹 清理旧文件..."
          rm -rf dist-${{ inputs.project }}/ || true
          rm -f dist-${{ inputs.project }}.zip || true
          rm -rf backend/ || true
          rm -rf frontend/ || true
          rm -rf node_modules/ || true
          rm -f package*.json || true
          rm -f *.js || true
          rm -f *.ts || true
          rm -f deploy.sh || true
          rm -f start.sh || true
          
          # 确保工作目录干净
          echo "📁 当前工作目录内容:"
          ls -la
          
          # 下载构建产物
          echo "⬇️ 开始下载构建产物..."
          gh run download ${{ inputs.run_id }} \
            --name "dist-${{ inputs.project }}" \
            --dir . \
            --repo ${{ inputs.source_repo }}
          
          # 验证下载结果
          echo "🔍 验证下载结果..."
          if [ -d "dist-${{ inputs.project }}" ]; then
            file_count=$(find "dist-${{ inputs.project }}" -type f | wc -l)
            echo "✅ 构建产物下载成功，包含 $file_count 个文件"
          elif [ -f "dist-${{ inputs.project }}.zip" ]; then
            echo "✅ 构建产物压缩包下载成功"
            unzip -q "dist-${{ inputs.project }}.zip"
            file_count=$(find "dist-${{ inputs.project }}" -type f | wc -l)
            echo "✅ 构建产物解压成功，包含 $file_count 个文件"
          else
            echo "📝 未找到标准构建产物，检查当前目录内容..."
            echo "📁 当前目录内容:"
            ls -la
            
            # 检查是否有其他构建产物文件
            if [ -d "backend" ] || [ -d "frontend" ] || [ -f "package.json" ] || [ -f "index.html" ]; then
              echo "✅ 发现项目文件，创建标准构建产物目录..."
              mkdir -p "dist-${{ inputs.project }}"
              
              # 移动所有项目文件到构建产物目录
              if [ -d "backend" ]; then
                mv backend "dist-${{ inputs.project }}/"
              fi
              if [ -d "frontend" ]; then
                mv frontend "dist-${{ inputs.project }}/"
              fi
              if [ -f "package.json" ]; then
                mv package.json "dist-${{ inputs.project }}/"
              fi
              if [ -f "index.html" ]; then
                mv index.html "dist-${{ inputs.project }}/"
              fi
              if [ -f "ecosystem.config.js" ]; then
                mv ecosystem.config.js "dist-${{ inputs.project }}/"
              fi
              if [ -f "deploy.sh" ]; then
                mv deploy.sh "dist-${{ inputs.project }}/"
              fi
              if [ -f "start.sh" ]; then
                mv start.sh "dist-${{ inputs.project }}/"
              fi
              
              file_count=$(find "dist-${{ inputs.project }}" -type f | wc -l)
              echo "✅ 构建产物重新组织完成，包含 $file_count 个文件"
              echo "📁 构建产物内容:"
              ls -la "dist-${{ inputs.project }}/"
            else
              echo "❌ 构建产物下载失败，无法找到有效的项目文件"
              exit 1
            fi
          fi
          
          # 最终验证
          if [ ! -d "dist-${{ inputs.project }}" ] || [ "$(find "dist-${{ inputs.project }}" -type f | wc -l)" -eq 0 ]; then
            echo "❌ 构建产物验证失败，目录为空或不存在"
            echo "📁 当前目录内容:"
            ls -la
            exit 1
          fi
          
          echo "✅ 构建产物验证通过"
        env:
          GH_TOKEN: ${{ inputs.deploy_center_pat || github.token }}



      - name: 调试下载结果
        run: |
          echo "🔍 调试下载结果..."
          echo "下载步骤退出码: ${{ steps.download-artifact.outcome }}"
          echo "当前目录: $(pwd)"
          echo "当前目录内容:"
          ls -la ./
          echo ""
          echo "🔍 检查构建产物目录..."
          if [ -d "./dist-${{ inputs.project }}" ]; then
            echo "✅ 找到构建产物目录"
            echo "📁 构建产物内容:"
            ls -la "./dist-${{ inputs.project }}/"
          else
            echo "📝 构建产物目录不存在，检查当前目录内容..."
            echo "📁 当前目录内容:"
            ls -la ./
            echo ""
            echo "🔍 所有文件和目录:"
            find . -type f -maxdepth 2
            find . -type d -maxdepth 2
            
            # 检查是否有压缩包
            if [ -f "deployment.tar.gz" ]; then
              echo "✅ 发现部署压缩包，正在解压..."
              mkdir -p "./dist-${{ inputs.project }}"
              tar -xzf deployment.tar.gz -C "./dist-${{ inputs.project }}"
              echo "✅ 部署压缩包解压完成"
              echo "📁 构建产物内容:"
              ls -la "./dist-${{ inputs.project }}/"
              echo "📊 文件数量: $(find "./dist-${{ inputs.project }}" -type f | wc -l)"
            # 检查当前目录是否包含构建产物文件
            elif [ -f "index.html" ] || [ -f "package.json" ] || [ -d "assets" ]; then
              echo "✅ 发现构建产物文件在当前目录，创建标准目录结构..."
              mkdir -p "./dist-${{ inputs.project }}"
              # 移动所有文件到构建产物目录（除了隐藏文件）
              find . -maxdepth 1 -type f ! -name ".*" -exec mv {} "./dist-${{ inputs.project }}/" \;
              find . -maxdepth 1 -type d ! -name "." ! -name ".*" -exec mv {} "./dist-${{ inputs.project }}/" \;
              echo "✅ 构建产物已移动到标准目录: ./dist-${{ inputs.project }}"
              echo "📁 构建产物内容:"
              ls -la "./dist-${{ inputs.project }}/"
              echo "📊 文件数量: $(find "./dist-${{ inputs.project }}" -type f | wc -l)"
            else
              echo "❌ 构建产物下载失败，无法继续部署"
              echo "🔍 期望的文件:"
              echo "- ./dist-${{ inputs.project }}/ (目录)"
              echo "- deployment.tar.gz (压缩包)"
              echo "- index.html, package.json, assets/ (静态文件)"
              exit 1
            fi
          fi

      - name: 调试SSH参数
        run: |
          echo "🔍 调试SSH连接参数..."
          echo "服务器主机: '${{ inputs.server_host }}'"
          echo "服务器用户: '${{ inputs.server_user }}'"
          echo "服务器端口: '${{ inputs.server_port }}'"
          echo "SSH密钥长度: $(echo '${{ inputs.server_key }}' | wc -c)"
          echo "SSH密钥是否为空: $([ -z '${{ inputs.server_key }}' ] && echo '是' || echo '否')"
          
          # 验证必需参数
          if [ -z "${{ inputs.server_host }}" ]; then
            echo "🚨 服务器主机地址为空"
            exit 1
          fi
          if [ -z "${{ inputs.server_user }}" ]; then
            echo "🚨 服务器用户名为空"
            exit 1
          fi
          if [ -z "${{ inputs.server_port }}" ]; then
            echo "🚨 服务器端口为空"
            exit 1
          fi
          if [ -z "${{ inputs.server_key }}" ]; then
            echo "🚨 SSH密钥为空"
            exit 1
          fi
          
          echo "✅ SSH参数验证通过"

      - name: 部署到服务器
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ inputs.server_host }}
          username: ${{ inputs.server_user }}
          key: ${{ inputs.server_key }}
          port: ${{ inputs.server_port }}
          script: |
            echo "🚀 开始部署项目: ${{ inputs.project }}"
            
            # 标准化目录结构
            APPS_ROOT="${{ inputs.apps_root || '/srv/apps' }}"
            STATIC_ROOT="${{ inputs.static_root || '/srv/static' }}"
            PROJECT="${{ inputs.project }}"
            DEPLOY_PATH=""
            
            # 根据部署类型确定部署路径
            if [[ "${{ inputs.deploy_type }}" == "backend" ]]; then
              # 后端项目部署到应用目录
              DEPLOY_PATH="$APPS_ROOT/$PROJECT"
              echo "📁 后端项目部署到: $DEPLOY_PATH"
            else
              # 静态项目部署到静态文件目录
              DEPLOY_PATH="$STATIC_ROOT/$PROJECT"
              echo "📁 静态项目部署到: $DEPLOY_PATH"
            fi
            
            # 创建部署目录
            sudo mkdir -p $DEPLOY_PATH
            sudo chown ${{ inputs.run_user || 'deploy' }}:${{ inputs.run_user || 'deploy' }} $DEPLOY_PATH
            
            # 创建项目专用备份目录
            if [[ "${{ inputs.deploy_type }}" == "backend" ]]; then
              BACKUP_ROOT="${{ inputs.backup_root || '/srv/backups' }}/apps"
            else
              BACKUP_ROOT="${{ inputs.backup_root || '/srv/backups' }}/static"
            fi
            PROJECT_BACKUP_DIR="$BACKUP_ROOT/$PROJECT"
            echo "📁 创建项目备份目录: $PROJECT_BACKUP_DIR"
            sudo mkdir -p "$PROJECT_BACKUP_DIR"
            sudo chmod 755 "$PROJECT_BACKUP_DIR"
            
            # 备份旧部署（如果存在）
            if [ -d "$DEPLOY_PATH" ] && [ "$(ls -A $DEPLOY_PATH)" ]; then
              echo "📋 备份旧部署目录: $DEPLOY_PATH"
              BACKUP_NAME="$PROJECT_BACKUP_DIR/$PROJECT.backup.$(date +%Y%m%d_%H%M%S)"
              sudo cp -r $DEPLOY_PATH $BACKUP_NAME
              echo "✅ 旧部署目录已备份到: $BACKUP_NAME"
              
              # 清理旧的备份文件，只保留最近5个
              echo "🧹 清理旧的备份文件..."
              BACKUP_FILES=$(ls -t "$PROJECT_BACKUP_DIR"/$PROJECT.backup.* 2>/dev/null | tail -n +6)
              if [ -n "$BACKUP_FILES" ]; then
                echo "🗑️ 删除旧的备份文件:"
                echo "$BACKUP_FILES" | xargs -r sudo rm -rf
                echo "✅ 旧备份文件已清理，保留最近5个备份"
              else
                echo "📋 没有需要清理的旧备份文件"
              fi
            else
              echo "📋 没有旧部署需要备份"
            fi
            
            # 清理目标部署目录（避免残留文件）
            echo "🧹 清理目标部署目录..."
            sudo rm -rf $DEPLOY_PATH/*
            sudo mkdir -p $DEPLOY_PATH
            sudo chown deploy:deploy $DEPLOY_PATH
            echo "✅ 部署目录已清理并重新创建"



      - name: 检查构建产物是否存在
        run: |
          echo "🔍 检查构建产物是否存在..."
          
          # 检查是否有构建产物目录
          if [ -d "./dist-${{ inputs.project }}" ]; then
            echo "✅ 找到构建产物目录: ./dist-${{ inputs.project }}"
            echo "📁 构建产物内容:"
            ls -la "./dist-${{ inputs.project }}/"
            echo "📊 文件数量: $(find "./dist-${{ inputs.project }}" -type f | wc -l)"
          else
            echo "📝 构建产物目录不存在，检查当前目录内容..."
            echo "📁 当前目录内容:"
            ls -la ./
            echo ""
            echo "🔍 所有文件和目录:"
            find . -type f -maxdepth 2
            find . -type d -maxdepth 2
            
            # 检查是否有压缩包
            if [ -f "deployment.tar.gz" ]; then
              echo "✅ 发现部署压缩包，正在解压..."
              mkdir -p "./dist-${{ inputs.project }}"
              tar -xzf deployment.tar.gz -C "./dist-${{ inputs.project }}"
              echo "✅ 部署压缩包解压完成"
              echo "📁 构建产物内容:"
              ls -la "./dist-${{ inputs.project }}/"
              echo "📊 文件数量: $(find "./dist-${{ inputs.project }}" -type f | wc -l)"
            # 检查当前目录是否包含构建产物文件
            elif [ -f "index.html" ] || [ -f "package.json" ] || [ -d "assets" ]; then
              echo "✅ 发现构建产物文件在当前目录，创建标准目录结构..."
              mkdir -p "./dist-${{ inputs.project }}"
              # 移动所有文件到构建产物目录（除了隐藏文件）
              find . -maxdepth 1 -type f ! -name ".*" -exec mv {} "./dist-${{ inputs.project }}/" \;
              find . -maxdepth 1 -type d ! -name "." ! -name ".*" -exec mv {} "./dist-${{ inputs.project }}/" \;
              echo "✅ 构建产物已移动到标准目录: ./dist-${{ inputs.project }}"
              echo "📁 构建产物内容:"
              ls -la "./dist-${{ inputs.project }}/"
              echo "📊 文件数量: $(find "./dist-${{ inputs.project }}" -type f | wc -l)"
            else
              echo "❌ 构建产物下载失败，无法继续部署"
              echo "🔍 期望的文件:"
              echo "- ./dist-${{ inputs.project }}/ (目录)"
              echo "- deployment.tar.gz (压缩包)"
              echo "- index.html, package.json, assets/ (静态文件)"
              exit 1
            fi
          fi

      - name: 直接部署到服务器
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ inputs.server_host }}
          username: ${{ inputs.server_user }}
          key: ${{ inputs.server_key }}
          port: ${{ inputs.server_port }}
          script: |
            echo "🚀 开始部署项目: ${{ inputs.project }}"
            
            # 标准化目录结构
            APPS_ROOT="${{ inputs.apps_root || '/srv/apps' }}"
            STATIC_ROOT="${{ inputs.static_root || '/srv/static' }}"
            PROJECT="${{ inputs.project }}"
            DEPLOY_PATH=""
            
            # 根据部署类型确定部署路径
            if [[ "${{ inputs.deploy_type }}" == "backend" ]]; then
              # 后端项目部署到应用目录
              DEPLOY_PATH="$APPS_ROOT/$PROJECT"
              echo "📁 后端项目部署到: $DEPLOY_PATH"
            else
              # 静态项目部署到静态文件目录
              DEPLOY_PATH="$STATIC_ROOT/$PROJECT"
              echo "📁 静态项目部署到: $DEPLOY_PATH"
            fi
            
            # 创建部署目录
            sudo mkdir -p $DEPLOY_PATH
            sudo chown ${{ inputs.run_user || 'deploy' }}:${{ inputs.run_user || 'deploy' }} $DEPLOY_PATH
            
            # 创建项目专用备份目录
            if [[ "${{ inputs.deploy_type }}" == "backend" ]]; then
              BACKUP_ROOT="${{ inputs.backup_root || '/srv/backups' }}/apps"
            else
              BACKUP_ROOT="${{ inputs.backup_root || '/srv/backups' }}/static"
            fi
            PROJECT_BACKUP_DIR="$BACKUP_ROOT/$PROJECT"
            echo "📁 创建项目备份目录: $PROJECT_BACKUP_DIR"
            sudo mkdir -p "$PROJECT_BACKUP_DIR"
            sudo chmod 755 "$PROJECT_BACKUP_DIR"
            
            # 备份旧部署（如果存在）
            if [ -d "$DEPLOY_PATH" ] && [ "$(ls -A $DEPLOY_PATH)" ]; then
              echo "📋 备份旧部署目录: $DEPLOY_PATH"
              BACKUP_NAME="$PROJECT_BACKUP_DIR/$PROJECT.backup.$(date +%Y%m%d_%H%M%S)"
              sudo cp -r $DEPLOY_PATH $BACKUP_NAME
              echo "✅ 旧部署目录已备份到: $BACKUP_NAME"
              
              # 清理旧的备份文件，只保留最近5个
              echo "🧹 清理旧的备份文件..."
              BACKUP_FILES=$(ls -t "$PROJECT_BACKUP_DIR"/$PROJECT.backup.* 2>/dev/null | tail -n +6)
              if [ -n "$BACKUP_FILES" ]; then
                echo "🗑️ 删除旧的备份文件:"
                echo "$BACKUP_FILES" | xargs -r sudo rm -rf
                echo "✅ 旧备份文件已清理，保留最近5个备份"
              else
                echo "📋 没有需要清理的旧备份文件"
              fi
            else
              echo "📋 没有旧部署需要备份"
            fi
            
            # 清理目标部署目录（避免残留文件）
            echo "🧹 清理目标部署目录..."
            sudo rm -rf $DEPLOY_PATH/*
            sudo mkdir -p $DEPLOY_PATH
            sudo chown deploy:deploy $DEPLOY_PATH
            echo "✅ 部署目录已清理并重新创建"

      - name: 调试构建产物
        run: |
          echo "🔍 调试构建产物..."
          echo "📁 当前目录: $(pwd)"
          echo "📁 当前目录内容:"
          ls -la
          echo ""
          echo "🔍 检查构建产物目录: ./dist-${{ inputs.project }}"
          if [ -d "./dist-${{ inputs.project }}" ]; then
            echo "✅ 构建产物目录存在"
            echo "📁 构建产物内容:"
            ls -la "./dist-${{ inputs.project }}/"
            echo "📊 文件数量: $(find "./dist-${{ inputs.project }}" -type f | wc -l)"
          else
            echo "❌ 构建产物目录不存在"
            echo "🔍 查找可能的构建产物..."
            find . -type d -name "*${{ inputs.project }}*" 2>/dev/null || echo "未找到相关目录"
          fi

      - name: 准备目标目录
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ inputs.server_host }}
          username: ${{ inputs.server_user }}
          key: ${{ inputs.server_key }}
          port: ${{ inputs.server_port }}
          script: |
            echo "📤 准备目标目录..."
            
            # 确定部署路径
            if [[ "${{ inputs.deploy_type }}" == "backend" ]]; then
              DEPLOY_PATH="${{ inputs.apps_root || '/srv/apps' }}/${{ inputs.project }}"
            else
              DEPLOY_PATH="${{ inputs.static_root || '/srv/static' }}/${{ inputs.project }}"
            fi
            
            echo "📁 目标部署路径: $DEPLOY_PATH"
            
            # 确保目标目录存在
            sudo mkdir -p "$DEPLOY_PATH"
            sudo chown deploy:deploy "$DEPLOY_PATH"
            
            echo "✅ 目标目录准备完成"

      - name: 上传构建产物到部署目录
        uses: appleboy/scp-action@v1.0.0
        with:
          host: ${{ inputs.server_host }}
          username: ${{ inputs.server_user }}
          key: ${{ inputs.server_key }}
          port: ${{ inputs.server_port }}
          source: "./dist-${{ inputs.project }}/"
          target: "${{ inputs.deploy_type == 'backend' && format('{0}/{1}', inputs.apps_root || '/srv/apps', inputs.project) || format('{0}/{1}', inputs.static_root || '/srv/static', inputs.project) }}"
          strip_components: 0
          overwrite: true

      - name: 验证上传结果
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ inputs.server_host }}
          username: ${{ inputs.server_user }}
          key: ${{ inputs.server_key }}
          port: ${{ inputs.server_port }}
          script: |
            echo "🔍 验证上传结果..."
            
            # 确定部署路径
            if [[ "${{ inputs.deploy_type }}" == "backend" ]]; then
              DEPLOY_PATH="${{ inputs.apps_root || '/srv/apps' }}/${{ inputs.project }}"
            else
              DEPLOY_PATH="${{ inputs.static_root || '/srv/static' }}/${{ inputs.project }}"
            fi
            
            echo "📁 检查部署目录: $DEPLOY_PATH"
            
            if [ -d "$DEPLOY_PATH" ]; then
              echo "✅ 部署目录存在"
              echo "📁 部署目录内容:"
              ls -la "$DEPLOY_PATH/"
              
              # 检查关键文件
              if [ -f "$DEPLOY_PATH/index.html" ]; then
                echo "✅ index.html 存在"
              else
                echo "❌ index.html 不存在"
              fi
              
              if [ -d "$DEPLOY_PATH/assets" ]; then
                echo "✅ assets 目录存在"
                echo "📊 assets 目录文件数量: $(find "$DEPLOY_PATH/assets" -type f | wc -l)"
              else
                echo "❌ assets 目录不存在"
              fi
              
              # 统计总文件数
              total_files=$(find "$DEPLOY_PATH" -type f | wc -l)
              echo "📊 总文件数量: $total_files"
              
              if [ "$total_files" -lt 10 ]; then
                echo "⚠️ 文件数量过少，可能存在上传问题"
                exit 1
              else
                echo "✅ 文件数量正常"
              fi
            else
              echo "❌ 部署目录不存在"
              exit 1
            fi

      - name: 修复目录结构
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ inputs.server_host }}
          username: ${{ inputs.server_user }}
          key: ${{ inputs.server_key }}
          port: ${{ inputs.server_port }}
          script: |
            echo "🔧 修复目录结构..."
            
            # 标准化目录结构
            APPS_ROOT="${{ inputs.apps_root || '/srv/apps' }}"
            STATIC_ROOT="${{ inputs.static_root || '/srv/static' }}"
            PROJECT="${{ inputs.project }}"
            
            # 根据部署类型确定部署路径
            if [[ "${{ inputs.deploy_type }}" == "backend" ]]; then
              DEPLOY_PATH="$APPS_ROOT/$PROJECT"
            else
              DEPLOY_PATH="$STATIC_ROOT/$PROJECT"
            fi
            
            echo "📁 检查部署路径: $DEPLOY_PATH"
            
            # 检查是否存在额外的dist-目录
            DIST_SUBDIR="$DEPLOY_PATH/dist-$PROJECT"
            if [ -d "$DIST_SUBDIR" ]; then
              echo "🔍 发现额外的dist-目录: $DIST_SUBDIR"
              echo "📁 dist-目录内容:"
              ls -la "$DIST_SUBDIR/"
              
              # 检查dist-目录下是否有正确的项目文件
              # 对于静态项目，检查是否有index.html或其他静态文件
              if [ -f "$DIST_SUBDIR/package.json" ] || [ -f "$DIST_SUBDIR/ecosystem.config.js" ] || [ -d "$DIST_SUBDIR/backend" ] || [ -d "$DIST_SUBDIR/frontend" ] || [ -f "$DIST_SUBDIR/index.html" ] || [ -d "$DIST_SUBDIR/assets" ] || [ -d "$DIST_SUBDIR/_assets" ]; then
                echo "✅ dist-目录包含正确的项目文件，正在修复目录结构..."
                
                # 创建临时目录
                TEMP_DIR="/tmp/fix-$PROJECT-$(date +%s)"
                mkdir -p "$TEMP_DIR"
                
                # 移动dist-目录下的所有内容到临时目录
                mv "$DIST_SUBDIR"/* "$TEMP_DIR/" 2>/dev/null || true
                mv "$DIST_SUBDIR"/.* "$TEMP_DIR/" 2>/dev/null || true
                
                # 删除空的dist-目录
                rmdir "$DIST_SUBDIR" 2>/dev/null || true
                
                # 移动临时目录的内容到项目根目录
                mv "$TEMP_DIR"/* "$DEPLOY_PATH/" 2>/dev/null || true
                mv "$TEMP_DIR"/.* "$DEPLOY_PATH/" 2>/dev/null || true
                
                # 删除临时目录
                rmdir "$TEMP_DIR" 2>/dev/null || true
                
                echo "✅ 目录结构修复完成"
              else
                echo "⚠️ dist-目录不包含预期的项目文件，保持原结构"
              fi
            else
              echo "✅ 目录结构正常，无需修复"
            fi
            
            # 显示最终的项目目录结构
            echo "📁 最终项目目录结构:"
            ls -la "$DEPLOY_PATH/"
            
            # 检查关键文件是否存在
            echo "🔍 检查关键文件:"
            if [ -f "$DEPLOY_PATH/package.json" ]; then
              echo "✅ package.json 存在"
            else
              echo "❌ package.json 不存在"
            fi
            
            if [ -f "$DEPLOY_PATH/ecosystem.config.js" ]; then
              echo "✅ ecosystem.config.js 存在"
            else
              echo "❌ ecosystem.config.js 不存在"
            fi
            
            if [ -d "$DEPLOY_PATH/backend" ]; then
              echo "✅ backend 目录存在"
            else
              echo "❌ backend 目录不存在"
            fi
            
            if [ -d "$DEPLOY_PATH/frontend" ]; then
              echo "✅ frontend 目录存在"
            else
              echo "❌ frontend 目录不存在"
            fi
            
            # 检查静态项目文件
            if [ -f "$DEPLOY_PATH/index.html" ]; then
              echo "✅ index.html 存在"
            else
              echo "❌ index.html 不存在"
            fi
            
            if [ -d "$DEPLOY_PATH/assets" ]; then
              echo "✅ assets 目录存在"
            else
              echo "❌ assets 目录不存在"
            fi
            
            if [ -d "$DEPLOY_PATH/_assets" ]; then
              echo "✅ _assets 目录存在"
            else
              echo "❌ _assets 目录不存在"
            fi
            
            # 设置正确的权限
            echo "🔧 设置文件权限..."
            chown -R deploy:deploy "$DEPLOY_PATH"
            chmod -R 755 "$DEPLOY_PATH"
            
            # 确保启动脚本可执行
            if [ -f "$DEPLOY_PATH/start.sh" ]; then
              chmod +x "$DEPLOY_PATH/start.sh"
              echo "✅ start.sh 设置为可执行"
            fi
            
            echo "✅ 目录结构修复和权限设置完成"

      - name: 验证部署结果
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ inputs.server_host }}
          username: ${{ inputs.server_user }}
          key: ${{ inputs.server_key }}
          port: ${{ inputs.server_port }}
          script: |
            echo "🔍 验证部署结果..."
            
            PROJECT="${{ inputs.project }}"
            
            # 根据部署类型确定部署路径
            if [[ "${{ inputs.deploy_type }}" == "backend" ]]; then
              DEPLOY_PATH="${{ inputs.apps_root || '/srv/apps' }}/$PROJECT"
            else
              DEPLOY_PATH="${{ inputs.static_root || '/srv/static' }}/$PROJECT"
            fi
            
            echo "📁 检查部署目录: $DEPLOY_PATH"
            
            if [ -d "$DEPLOY_PATH" ] && [ "$(ls -A $DEPLOY_PATH)" ]; then
              final_file_count=$(find "$DEPLOY_PATH" -type f | wc -l)
              echo "✅ 部署验证通过"
              echo "📁 部署目录内容:"
              ls -la $DEPLOY_PATH/
              echo "📊 最终文件数量: $final_file_count"
              if [ "$final_file_count" -gt 0 ]; then
                echo "✅ 部署成功"
                exit 0
              else
                echo "❌ 部署后目录为空"
                exit 1
              fi
            else
              echo "🚨 部署验证失败"
              exit 1
            fi



      - name: 部署失败自动回滚
        if: failure()
        run: |
          echo "❌ 部署失败，开始自动回滚..."
          
          # 创建临时SSH密钥文件
          echo "${{ inputs.server_key }}" > /tmp/deploy_key
          chmod 600 /tmp/deploy_key
          
          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 \
            -i /tmp/deploy_key \
            -p ${{ inputs.server_port }} \
            ${{ inputs.server_user }}@${{ inputs.server_host }} << 'EOF'
            
            PROJECT="${{ inputs.project }}"
            
            if [ "${{ inputs.deploy_type }}" = "static" ]; then
              DEPLOY_PATH="${{ inputs.static_root || '/srv/static' }}/$PROJECT"
              BACKUP_ROOT="${{ inputs.backup_root || '/srv/backups' }}/static"
            else
              DEPLOY_PATH="${{ inputs.apps_root || '/srv/apps' }}/$PROJECT"
              BACKUP_ROOT="${{ inputs.backup_root || '/srv/backups' }}/apps"
            fi
            
            PROJECT_BACKUP_DIR="$BACKUP_ROOT/$PROJECT"
            
            # 检查是否有备份
            echo "🔍 查找最新备份..."
            echo "📁 备份目录: $PROJECT_BACKUP_DIR"
            
            if [ -d "$PROJECT_BACKUP_DIR" ]; then
              echo "📁 备份目录内容:"
              ls -la "$PROJECT_BACKUP_DIR"
              
              # 查找最新的备份目录
              LATEST_BACKUP=$(find "$PROJECT_BACKUP_DIR" -name "$PROJECT.backup.*" -type d 2>/dev/null | sort -r | head -1)
              
              if [ -n "$LATEST_BACKUP" ] && [ -d "$LATEST_BACKUP" ]; then
                echo "📦 找到最新备份: $LATEST_BACKUP"
                echo "📁 备份内容:"
                ls -la "$LATEST_BACKUP"
                
                sudo rm -rf "$DEPLOY_PATH"/*
                sudo cp -r "$LATEST_BACKUP"/* "$DEPLOY_PATH/"
                sudo chown -R ${{ inputs.run_user || 'deploy' }}:${{ inputs.run_user || 'deploy' }} "$DEPLOY_PATH"
                echo "✅ 回滚完成，已恢复到: $LATEST_BACKUP"
              else
                echo "⚠️ 未找到有效的备份目录"
                echo "🔍 可用的备份:"
                find "$PROJECT_BACKUP_DIR" -name "$PROJECT.backup.*" -type d 2>/dev/null || echo "没有找到备份"
              fi
            else
              echo "⚠️ 备份目录不存在: $PROJECT_BACKUP_DIR"
            fi
          EOF

      - name: 设置输出
        id: set-outputs
        run: |
          if [[ "${{ inputs.deploy_type }}" == "backend" ]]; then
            DEPLOY_PATH="/srv/apps/${{ inputs.project }}"
          else
            DEPLOY_PATH="/srv/static/${{ inputs.project }}"
          fi
          
          echo "deploy_success=true" >> $GITHUB_OUTPUT
          echo "deploy_path=$DEPLOY_PATH" >> $GITHUB_OUTPUT
          echo "✅ 输出已设置"
          echo "- deploy_success: true"
          echo "- deploy_path: $DEPLOY_PATH"

      - name: 通知部署仪表板
        if: success()
        run: |
          echo "📤 通知 axi-project-dashboard 部署成功..."
          
          # 计算部署耗时
          DEPLOY_START_TIME="${{ env.DEPLOY_START_TIME }}"
          DEPLOY_END_TIME=$(date +%s)
          DEPLOY_DURATION=$((DEPLOY_END_TIME - DEPLOY_START_TIME))
          
          # 构建通知数据
          NOTIFICATION_DATA=$(cat <<EOF
          {
            "type": "deployment_completed",
            "project": "${{ inputs.project }}",
            "deployment_id": "${{ inputs.run_id }}",
            "status": "success",
            "duration": $DEPLOY_DURATION,
            "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%S.000Z")",
            "workflow_name": "deploy-project",
            "workflow_id": "${{ github.run_id }}",
            "sourceRepo": "${{ inputs.source_repo }}",
            "deployType": "${{ inputs.deploy_type }}",
            "serverHost": "${{ inputs.server_host }}",
            "logs": "部署成功，耗时 ${DEPLOY_DURATION} 秒",
            "started_at": "$(date -d @$DEPLOY_START_TIME -u +"%Y-%m-%dT%H:%M:%S.000Z")",
            "completed_at": "$(date -u +"%Y-%m-%dT%H:%M:%S.000Z")"
          }
          EOF
          )
          
          echo "📊 部署信息:"
          echo "- 项目: ${{ inputs.project }}"
          echo "- 状态: success"
          echo "- 耗时: ${DEPLOY_DURATION}秒"
          echo "- 源仓库: ${{ inputs.source_repo }}"
          echo "- 运行ID: ${{ inputs.run_id }}"
          echo "- 部署类型: ${{ inputs.deploy_type }}"
          
          # 发送通知到 axi-project-dashboard
          DASHBOARD_URL="https://redamancy.com.cn/project-dashboard/api/webhooks/deployment"
          
          RESPONSE=$(curl -s -w "\n%{http_code}" \
            -X POST \
            -H "Content-Type: application/json" \
            -H "User-Agent: axi-deploy/1.0" \
            -d "$NOTIFICATION_DATA" \
            "$DASHBOARD_URL" \
            2>/dev/null)
          
          # 解析响应
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$RESPONSE" | head -n -1)
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "✅ 部署通知发送成功"
            echo "响应: $RESPONSE_BODY"
          else
            echo "⚠️ 部署通知发送失败 (HTTP $HTTP_CODE)"
            echo "响应: $RESPONSE_BODY"
            # 不退出，因为这只是通知，不应该影响部署流程
          fi

      - name: 通知部署失败
        if: failure()
        run: |
          echo "📤 通知 axi-project-dashboard 部署失败..."
          
          # 计算部署耗时
          DEPLOY_START_TIME="${{ env.DEPLOY_START_TIME }}"
          DEPLOY_END_TIME=$(date +%s)
          DEPLOY_DURATION=$((DEPLOY_END_TIME - DEPLOY_START_TIME))
          
          # 构建通知数据
          NOTIFICATION_DATA=$(cat <<EOF
          {
            "type": "deployment_completed",
            "project": "${{ inputs.project }}",
            "deployment_id": "${{ inputs.run_id }}",
            "status": "failed",
            "duration": $DEPLOY_DURATION,
            "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%S.000Z")",
            "workflow_name": "deploy-project",
            "workflow_id": "${{ github.run_id }}",
            "sourceRepo": "${{ inputs.source_repo }}",
            "deployType": "${{ inputs.deploy_type }}",
            "serverHost": "${{ inputs.server_host }}",
            "errorMessage": "部署失败，请查看 GitHub Actions 日志",
            "started_at": "$(date -d @$DEPLOY_START_TIME -u +"%Y-%m-%dT%H:%M:%S.000Z")",
            "completed_at": "$(date -u +"%Y-%m-%dT%H:%M:%S.000Z")"
          }
          EOF
          )
          
          echo "📊 部署信息:"
          echo "- 项目: ${{ inputs.project }}"
          echo "- 状态: failed"
          echo "- 耗时: ${DEPLOY_DURATION}秒"
          echo "- 源仓库: ${{ inputs.source_repo }}"
          echo "- 运行ID: ${{ inputs.run_id }}"
          echo "- 部署类型: ${{ inputs.deploy_type }}"
          
          # 发送通知到 axi-project-dashboard
          DASHBOARD_URL="https://redamancy.com.cn/project-dashboard/api/webhooks/deployment"
          
          RESPONSE=$(curl -s -w "\n%{http_code}" \
            -X POST \
            -H "Content-Type: application/json" \
            -H "User-Agent: axi-deploy/1.0" \
            -d "$NOTIFICATION_DATA" \
            "$DASHBOARD_URL" \
            2>/dev/null)
          
          # 解析响应
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$RESPONSE" | head -n -1)
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "✅ 部署失败通知发送成功"
            echo "响应: $RESPONSE_BODY"
          else
            echo "⚠️ 部署失败通知发送失败 (HTTP $HTTP_CODE)"
            echo "响应: $RESPONSE_BODY"
            # 不退出，因为这只是通知，不应该影响部署流程
          fi
