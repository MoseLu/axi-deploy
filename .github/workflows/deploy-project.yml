name: Deploy Project

description: "项目部署 - 部署项目到目标服务器"

on:
  workflow_call:
    inputs:
      project:
        required: true
        type: string
        description: "项目名称"
      source_repo:
        required: true
        type: string
        description: "源仓库 (owner/repo)"
      run_id:
        required: true
        type: string
        description: "构建运行ID"
      deploy_type:
        required: true
        type: string
        description: "部署类型 (backend/static)"
        default: "static"
      server_host:
        required: true
        type: string
        description: "服务器地址"
      server_user:
        required: true
        type: string
        description: "服务器用户"
      server_key:
        required: true
        type: string
        description: "服务器密钥"
      server_port:
        required: true
        type: string
        description: "服务器端口"
      deploy_center_pat:
        required: false
        type: string
        description: "GitHub Token用于下载构建产物（可选，默认使用GITHUB_TOKEN）"
      apps_root:
        required: false
        type: string
        description: "应用目录路径"
        default: "/srv/apps"
      static_root:
        required: false
        type: string
        description: "静态文件目录路径"
        default: "/srv/static"
      backup_root:
        required: false
        type: string
        description: "备份根目录"
        default: "/srv/backups"
      mysql_config:
        required: false
        type: string
        description: "MySQL 配置（base64 编码的 JSON）"
      run_user:
        required: false
        type: string
        description: "运行用户"
        default: "deploy"

    outputs:
      deploy_success:
        description: "部署是否成功"
        value: ${{ jobs.deploy.outputs.deploy_success }}
      deploy_path:
        description: "部署路径"
        value: ${{ jobs.deploy.outputs.deploy_path }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      contents: read
      actions: read
      packages: read
    outputs:
      deploy_success: ${{ steps.set-outputs.outputs.deploy_success }}
      deploy_path: ${{ steps.set-outputs.outputs.deploy_path }}
    
    steps:
      - name: 验证输入参数
        run: |
          echo "🔍 验证输入参数..."
          echo "- 项目: ${{ inputs.project }}"
          echo "- 源仓库: ${{ inputs.source_repo }}"
          echo "- 运行ID: ${{ inputs.run_id }}"
          echo "- 部署类型: ${{ inputs.deploy_type }}"
          echo "- 服务器: ${{ inputs.server_host }}:${{ inputs.server_port }}"
          
          # 记录部署开始时间
          echo "DEPLOY_START_TIME=$(date +%s)" >> $GITHUB_ENV
          
          echo "✅ 输入参数验证通过"

      - name: 下载构建产物
        run: |
          # 彻底清理旧文件和目录
          echo "🧹 清理旧文件..."
          rm -rf dist-${{ inputs.project }}/ || true
          rm -f dist-${{ inputs.project }}.zip || true
          rm -rf backend/ || true
          rm -rf frontend/ || true
          rm -rf node_modules/ || true
          rm -f package*.json || true
          rm -f *.js || true
          rm -f *.ts || true
          rm -f deploy.sh || true
          rm -f start.sh || true
          
          # 确保工作目录干净
          echo "📁 当前工作目录内容:"
          ls -la
          
          # 下载构建产物
          echo "⬇️ 开始下载构建产物..."
          gh run download ${{ inputs.run_id }} \
            --name "dist-${{ inputs.project }}" \
            --dir . \
            --repo ${{ inputs.source_repo }}
          
          # 验证下载结果
          echo "🔍 验证下载结果..."
          
          # 检查是否有 deployment.tar.gz 文件（axi-star-cloud 等项目的格式）
          if [ -f "deployment.tar.gz" ]; then
            echo "✅ 发现 deployment.tar.gz 文件，解压到标准目录..."
            mkdir -p "dist-${{ inputs.project }}"
            tar -xzf deployment.tar.gz -C "dist-${{ inputs.project }}"
            file_count=$(find "dist-${{ inputs.project }}" -type f | wc -l)
            echo "✅ deployment.tar.gz 解压成功，包含 $file_count 个文件"
            echo "📁 解压后内容:"
            ls -la "dist-${{ inputs.project }}/"
          elif [ -f "dist-${{ inputs.project }}.tar.gz" ]; then
            echo "✅ 构建产物压缩包下载成功"
            echo "📦 解压构建产物压缩包..."
            tar -xzf "dist-${{ inputs.project }}.tar.gz"
            
            # 检查解压后的目录结构
            if [ -d "dist" ]; then
              echo "✅ 压缩包解压成功，重命名目录..."
              mv dist "dist-${{ inputs.project }}"
              file_count=$(find "dist-${{ inputs.project }}" -type f | wc -l)
              echo "✅ 构建产物解压成功，包含 $file_count 个文件"
            else
              echo "❌ 压缩包解压后未找到预期的 dist 目录"
              echo "📁 解压后目录内容:"
              ls -la
              exit 1
            fi
          elif [ -d "dist-${{ inputs.project }}" ]; then
            file_count=$(find "dist-${{ inputs.project }}" -type f | wc -l)
            echo "✅ 构建产物下载成功，包含 $file_count 个文件"
          elif [ -f "dist-${{ inputs.project }}.zip" ]; then
            echo "✅ 构建产物压缩包下载成功"
            unzip -q "dist-${{ inputs.project }}.zip"
            file_count=$(find "dist-${{ inputs.project }}" -type f | wc -l)
            echo "✅ 构建产物解压成功，包含 $file_count 个文件"
          elif [ -d "docs" ] && [ -d "docs/.vitepress" ] && [ -d "docs/.vitepress/dist" ]; then
            echo "✅ 发现 VitePress 构建产物目录结构"
            echo "📦 移动构建产物到标准位置..."
            mv docs/.vitepress/dist "dist-${{ inputs.project }}"
            file_count=$(find "dist-${{ inputs.project }}" -type f | wc -l)
            echo "✅ 构建产物移动成功，包含 $file_count 个文件"
          else
            echo "📝 未找到标准构建产物，检查当前目录内容..."
            echo "📁 当前目录内容:"
            ls -la
            
            # 检查是否有其他构建产物文件
            if [ -d "backend" ] || [ -d "frontend" ] || [ -f "package.json" ] || [ -f "index.html" ] || [ -f "star-cloud-linux" ] || [ -d "front" ]; then
              echo "✅ 发现项目文件，创建标准构建产物目录..."
              mkdir -p "dist-${{ inputs.project }}"
              
              # 移动所有项目文件到构建产物目录
              if [ -d "backend" ]; then
                mv backend "dist-${{ inputs.project }}/"
              fi
              if [ -d "frontend" ]; then
                mv frontend "dist-${{ inputs.project }}/"
              fi
              if [ -d "front" ]; then
                mv front "dist-${{ inputs.project }}/"
              fi
              if [ -f "package.json" ]; then
                mv package.json "dist-${{ inputs.project }}/"
              fi
              if [ -f "index.html" ]; then
                mv index.html "dist-${{ inputs.project }}/"
              fi
              if [ -f "ecosystem.config.js" ]; then
                mv ecosystem.config.js "dist-${{ inputs.project }}/"
              fi
              if [ -f "deploy.sh" ]; then
                mv deploy.sh "dist-${{ inputs.project }}/"
              fi
              if [ -f "start.sh" ]; then
                mv start.sh "dist-${{ inputs.project }}/"
              fi
              if [ -f "star-cloud-linux" ]; then
                mv star-cloud-linux "dist-${{ inputs.project }}/"
              fi
              if [ -f "star-cloud.service" ]; then
                mv star-cloud.service "dist-${{ inputs.project }}/"
              fi
              if [ -d "config" ]; then
                mv config "dist-${{ inputs.project }}/"
              fi
              
              file_count=$(find "dist-${{ inputs.project }}" -type f | wc -l)
              echo "✅ 构建产物重新组织完成，包含 $file_count 个文件"
              echo "📁 构建产物内容:"
              ls -la "dist-${{ inputs.project }}/"
            else
              echo "❌ 构建产物下载失败，无法找到有效的项目文件"
              echo "📁 当前目录内容:"
              ls -la
              exit 1
            fi
          fi
          
          # 最终验证
          if [ ! -d "dist-${{ inputs.project }}" ] || [ "$(find "dist-${{ inputs.project }}" -type f | wc -l)" -eq 0 ]; then
            echo "❌ 构建产物验证失败，目录为空或不存在"
            echo "📁 当前目录内容:"
            ls -la
            exit 1
          fi
          
          echo "✅ 构建产物验证通过"
        env:
          GH_TOKEN: ${{ inputs.deploy_center_pat || github.token }}

      - name: 部署到服务器
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ inputs.server_host }}
          username: ${{ inputs.server_user }}
          key: ${{ inputs.server_key }}
          port: ${{ inputs.server_port }}
          script: |
            echo "🚀 开始部署 ${{ inputs.project }}..."
            
            PROJECT="${{ inputs.project }}"
            DEPLOY_TYPE="${{ inputs.deploy_type }}"
            APPS_ROOT="${{ inputs.apps_root }}"
            STATIC_ROOT="${{ inputs.static_root }}"
            BACKUP_ROOT="${{ inputs.backup_root }}"
            RUN_USER="${{ inputs.run_user }}"
            
            echo "📋 部署配置:"
            echo "- 项目: $PROJECT"
            echo "- 类型: $DEPLOY_TYPE"
            echo "- 应用目录: $APPS_ROOT"
            echo "- 静态目录: $STATIC_ROOT"
            echo "- 备份目录: $BACKUP_ROOT"
            echo "- 运行用户: $RUN_USER"
            
            # 确定部署路径
            if [ "$DEPLOY_TYPE" = "backend" ]; then
              DEPLOY_PATH="$APPS_ROOT/$PROJECT"
              BACKUP_PATH="$BACKUP_ROOT/$PROJECT"
            else
              DEPLOY_PATH="$STATIC_ROOT/$PROJECT"
              BACKUP_PATH="$BACKUP_ROOT/$PROJECT"
            fi
            
            echo "📁 部署路径: $DEPLOY_PATH"
            echo "📁 备份路径: $BACKUP_PATH"
            
            # 创建必要的目录
            sudo mkdir -p "$APPS_ROOT" "$STATIC_ROOT" "$BACKUP_ROOT"
            sudo chown -R $RUN_USER:$RUN_USER "$APPS_ROOT" "$STATIC_ROOT" "$BACKUP_ROOT"
            
            # 备份现有部署（如果存在）
            if [ -d "$DEPLOY_PATH" ]; then
              echo "📦 备份现有部署..."
              BACKUP_TIMESTAMP=$(date +%Y%m%d_%H%M%S)
              BACKUP_NAME="$PROJECT.backup.$BACKUP_TIMESTAMP"
              sudo cp -r "$DEPLOY_PATH" "$BACKUP_PATH/$BACKUP_NAME"
              sudo chown -R $RUN_USER:$RUN_USER "$BACKUP_PATH/$BACKUP_NAME"
              echo "✅ 现有部署已备份到: $BACKUP_PATH/$BACKUP_NAME"
              
              # 清理旧备份（保留最近5个）
              echo "🧹 清理旧备份..."
              OLD_BACKUPS=$(ls -t "$BACKUP_PATH"/$PROJECT.backup.* 2>/dev/null | tail -n +6)
              if [ -n "$OLD_BACKUPS" ]; then
                echo "🗑️ 删除旧备份:"
                echo "$OLD_BACKUPS" | xargs -r sudo rm -rf
              fi
            else
              echo "📋 没有现有部署需要备份"
            fi
            
            # 清理目标部署目录（避免残留文件）
            echo "🧹 清理目标部署目录..."
            sudo rm -rf "$DEPLOY_PATH"/*
            sudo mkdir -p "$DEPLOY_PATH"
            sudo chown -R $RUN_USER:$RUN_USER "$DEPLOY_PATH"
            
            echo "✅ 目标目录已准备就绪"

      - name: 上传构建产物到部署目录
        uses: appleboy/scp-action@v1.0.0
        with:
          host: ${{ inputs.server_host }}
          username: ${{ inputs.server_user }}
          key: ${{ inputs.server_key }}
          port: ${{ inputs.server_port }}
          source: "./dist-${{ inputs.project }}/"
          target: "${{ inputs.deploy_type == 'backend' && format('{0}/{1}', inputs.apps_root || '/srv/apps', inputs.project) || format('{0}/{1}', inputs.static_root || '/srv/static', inputs.project) }}"
          strip_components: 0
          overwrite: true

      - name: 验证部署结果
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ inputs.server_host }}
          username: ${{ inputs.server_user }}
          key: ${{ inputs.server_key }}
          port: ${{ inputs.server_port }}
          script: |
            echo "🔍 验证部署结果..."
            
            PROJECT="${{ inputs.project }}"
            
            # 根据部署类型确定部署路径
            if [[ "${{ inputs.deploy_type }}" == "backend" ]]; then
              DEPLOY_PATH="${{ inputs.apps_root || '/srv/apps' }}/$PROJECT"
            else
              DEPLOY_PATH="${{ inputs.static_root || '/srv/static' }}/$PROJECT"
            fi
            
            echo "📁 检查部署目录: $DEPLOY_PATH"
            
            if [ -d "$DEPLOY_PATH" ] && [ "$(ls -A $DEPLOY_PATH)" ]; then
              final_file_count=$(find "$DEPLOY_PATH" -type f | wc -l)
              echo "✅ 部署验证通过"
              echo "📁 部署目录内容:"
              ls -la $DEPLOY_PATH/
              echo "📊 最终文件数量: $final_file_count"
              if [ "$final_file_count" -gt 0 ]; then
                echo "✅ 部署成功"
                exit 0
              else
                echo "❌ 部署后目录为空"
                exit 1
              fi
            else
              echo "🚨 部署验证失败"
              exit 1
            fi

      - name: MySQL 数据库备份
        if: inputs.deploy_type == 'backend' && inputs.mysql_config != ''
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ inputs.server_host }}
          username: ${{ inputs.server_user }}
          key: ${{ inputs.server_key }}
          port: ${{ inputs.server_port }}
          script: |
            echo "🗄️ 开始 MySQL 数据库备份..."
            
            # 解析 MySQL 配置
            MYSQL_CONFIG_JSON=$(echo "${{ inputs.mysql_config }}" | base64 -d)
            echo "📄 MySQL 配置: $MYSQL_CONFIG_JSON"
            
            # 提取各个参数
            MYSQL_HOST=$(echo "$MYSQL_CONFIG_JSON" | jq -r '.mysql_host // "localhost"')
            MYSQL_PORT=$(echo "$MYSQL_CONFIG_JSON" | jq -r '.mysql_port // "3306"')
            MYSQL_USER=$(echo "$MYSQL_CONFIG_JSON" | jq -r '.mysql_user // "root"')
            MYSQL_PASSWORD=$(echo "$MYSQL_CONFIG_JSON" | jq -r '.mysql_password // ""')
            DATABASE_NAME=$(echo "$MYSQL_CONFIG_JSON" | jq -r '.database_name // ""')
            BACKUP_METHOD=$(echo "$MYSQL_CONFIG_JSON" | jq -r '.backup_method // "mysqldump"')
            BACKUP_RETENTION_DAYS=$(echo "$MYSQL_CONFIG_JSON" | jq -r '.backup_retention_days // "30"')
            PROJECT="${{ inputs.project }}"
            APPS_ROOT="${{ inputs.apps_root }}"
            BACKUP_ROOT="${{ inputs.backup_root }}"
            
            echo "📋 MySQL 配置:"
            echo "- 主机: $MYSQL_HOST:$MYSQL_PORT"
            echo "- 用户: $MYSQL_USER"
            echo "- 数据库: $DATABASE_NAME"
            echo "- 备份方法: $BACKUP_METHOD"
            echo "- 保留天数: $BACKUP_RETENTION_DAYS"
            
            # 检查 MySQL 连接
            echo "🔍 检查 MySQL 连接..."
            
            # 尝试从服务器配置中获取密码
            echo "🔍 尝试从服务器配置获取 MySQL 密码..."
            SERVER_PASSWORD=""
            
            # 检查 init-database.sh 中的密码
            if [ -f "/srv/apps/$PROJECT/scripts/init-database.sh" ]; then
              echo "🔍 检查 init-database.sh 中的密码配置..."
              SERVER_PASSWORD=$(grep -o 'DB_PASSWORD="[^"]*"' "/srv/apps/$PROJECT/scripts/init-database.sh" | cut -d'"' -f2)
              if [ -n "$SERVER_PASSWORD" ]; then
                echo "✅ 从 init-database.sh 获取到密码"
              fi
            fi
            
            # 检查配置文件中的密码
            if [ -z "$SERVER_PASSWORD" ] && [ -f "/srv/apps/$PROJECT/config/config.yaml" ]; then
              echo "🔍 检查 config.yaml 中的密码配置..."
              SERVER_PASSWORD=$(grep -A5 "database:" "/srv/apps/$PROJECT/config/config.yaml" | grep "password:" | awk '{print $2}' | tr -d "'" | tr -d '"')
              if [ -n "$SERVER_PASSWORD" ]; then
                echo "✅ 从 config.yaml 获取到密码"
              fi
            fi
            
            # 尝试不同的连接方式
            if [ -n "$MYSQL_PASSWORD" ]; then
              echo "🔍 尝试使用传递的密码连接..."
              if mysql -h"$MYSQL_HOST" -P"$MYSQL_PORT" -u"$MYSQL_USER" -p"$MYSQL_PASSWORD" -e "SELECT 1;" >/dev/null 2>&1; then
                echo "✅ MySQL 连接成功（使用传递的密码）"
                MYSQL_CMD="mysql -h$MYSQL_HOST -P$MYSQL_PORT -u$MYSQL_USER -p$MYSQL_PASSWORD"
                MYSQLDUMP_CMD="mysqldump -h$MYSQL_HOST -P$MYSQL_PORT -u$MYSQL_USER -p$MYSQL_PASSWORD"
              elif [ -n "$SERVER_PASSWORD" ]; then
                echo "🔍 尝试使用服务器配置密码连接..."
                if mysql -h"$MYSQL_HOST" -P"$MYSQL_PORT" -u"$MYSQL_USER" -p"$SERVER_PASSWORD" -e "SELECT 1;" >/dev/null 2>&1; then
                  echo "✅ MySQL 连接成功（使用服务器配置密码）"
                  # 创建临时密码文件（更安全的方式）
                  echo "[client]" > /tmp/mysql.cnf
                  echo "password=$SERVER_PASSWORD" >> /tmp/mysql.cnf
                  chmod 600 /tmp/mysql.cnf
                  MYSQL_CMD="mysql --defaults-extra-file=/tmp/mysql.cnf -h$MYSQL_HOST -P$MYSQL_PORT -u$MYSQL_USER"
                  MYSQLDUMP_CMD="mysqldump --defaults-extra-file=/tmp/mysql.cnf -h$MYSQL_HOST -P$MYSQL_PORT -u$MYSQL_USER"
                else
                  echo "❌ 使用服务器配置密码连接失败，尝试无密码连接..."
                  if mysql -h"$MYSQL_HOST" -P"$MYSQL_PORT" -u"$MYSQL_USER" -e "SELECT 1;" >/dev/null 2>&1; then
                    echo "✅ MySQL 连接成功（无密码）"
                    MYSQL_CMD="mysql -h$MYSQL_HOST -P$MYSQL_PORT -u$MYSQL_USER"
                    MYSQLDUMP_CMD="mysqldump -h$MYSQL_HOST -P$MYSQL_PORT -u$MYSQL_USER"
                  else
                    echo "❌ MySQL 连接失败，跳过备份"
                    exit 0
                  fi
                fi
              else
                echo "❌ 使用传递的密码连接失败，尝试无密码连接..."
                if mysql -h"$MYSQL_HOST" -P"$MYSQL_PORT" -u"$MYSQL_USER" -e "SELECT 1;" >/dev/null 2>&1; then
                  echo "✅ MySQL 连接成功（无密码）"
                  MYSQL_CMD="mysql -h$MYSQL_HOST -P$MYSQL_PORT -u$MYSQL_USER"
                  MYSQLDUMP_CMD="mysqldump -h$MYSQL_HOST -P$MYSQL_PORT -u$MYSQL_USER"
                else
                  echo "❌ MySQL 连接失败，跳过备份"
                  exit 0
                fi
              fi
            elif [ -n "$SERVER_PASSWORD" ]; then
              echo "🔍 尝试使用服务器配置密码连接..."
              if mysql -h"$MYSQL_HOST" -P"$MYSQL_PORT" -u"$MYSQL_USER" -p"$SERVER_PASSWORD" -e "SELECT 1;" >/dev/null 2>&1; then
                echo "✅ MySQL 连接成功（使用服务器配置密码）"
                # 创建临时密码文件（更安全的方式）
                echo "[client]" > /tmp/mysql.cnf
                echo "password=$SERVER_PASSWORD" >> /tmp/mysql.cnf
                chmod 600 /tmp/mysql.cnf
                MYSQL_CMD="mysql --defaults-extra-file=/tmp/mysql.cnf -h$MYSQL_HOST -P$MYSQL_PORT -u$MYSQL_USER"
                MYSQLDUMP_CMD="mysqldump --defaults-extra-file=/tmp/mysql.cnf -h$MYSQL_HOST -P$MYSQL_PORT -u$MYSQL_USER"
              else
                echo "❌ 使用服务器配置密码连接失败，尝试无密码连接..."
                if mysql -h"$MYSQL_HOST" -P"$MYSQL_PORT" -u"$MYSQL_USER" -e "SELECT 1;" >/dev/null 2>&1; then
                  echo "✅ MySQL 连接成功（无密码）"
                  MYSQL_CMD="mysql -h$MYSQL_HOST -P$MYSQL_PORT -u$MYSQL_USER"
                  MYSQLDUMP_CMD="mysqldump -h$MYSQL_HOST -P$MYSQL_PORT -u$MYSQL_USER"
                else
                  echo "❌ MySQL 连接失败，跳过备份"
                  exit 0
                fi
              fi
            else
              echo "🔍 尝试无密码连接..."
              if mysql -h"$MYSQL_HOST" -P"$MYSQL_PORT" -u"$MYSQL_USER" -e "SELECT 1;" >/dev/null 2>&1; then
                echo "✅ MySQL 连接成功（无密码）"
                MYSQL_CMD="mysql -h$MYSQL_HOST -P$MYSQL_PORT -u$MYSQL_USER"
                MYSQLDUMP_CMD="mysqldump -h$MYSQL_HOST -P$MYSQL_PORT -u$MYSQL_USER"
              else
                echo "❌ MySQL 连接失败，跳过备份"
                exit 0
              fi
            fi
            
            # 创建备份目录
            BACKUP_DIR="$BACKUP_ROOT/$PROJECT/mysql"
            sudo mkdir -p "$BACKUP_DIR"
            sudo chown -R $USER:$USER "$BACKUP_DIR"
            
            # 执行备份
            TIMESTAMP=$(date +%Y%m%d_%H%M%S)
            BACKUP_FILE="$BACKUP_DIR/${DATABASE_NAME}_${TIMESTAMP}.sql"
            
            echo "📦 执行数据库备份..."
            if [ "$BACKUP_METHOD" = "mysqldump" ]; then
              $MYSQLDUMP_CMD \
                --single-transaction --routines --triggers --events \
                "$DATABASE_NAME" > "$BACKUP_FILE"
            else
              echo "❌ 不支持的备份方法: $BACKUP_METHOD"
              exit 1
            fi
            
            if [ $? -eq 0 ]; then
              echo "✅ 数据库备份成功: $BACKUP_FILE"
              
              # 压缩备份文件
              gzip "$BACKUP_FILE"
              echo "📦 备份文件已压缩: ${BACKUP_FILE}.gz"
              
              # 清理旧备份
              echo "🧹 清理过期备份文件..."
              find "$BACKUP_DIR" -name "*.sql.gz" -mtime +$BACKUP_RETENTION_DAYS -delete
              echo "✅ 过期备份文件已清理"
              
              # 设置定时备份任务
              if [ -n "$MYSQL_PASSWORD" ]; then
                CRON_JOB="0 2 * * * mysqldump -h$MYSQL_HOST -P$MYSQL_PORT -u$MYSQL_USER -p$MYSQL_PASSWORD --single-transaction --routines --triggers --events $DATABASE_NAME | gzip > $BACKUP_DIR/${DATABASE_NAME}_\$(date +\\%Y\\%m\\%d_\\%H\\%M\\%S).sql.gz"
              elif [ -n "$SERVER_PASSWORD" ]; then
                # 创建定时任务使用的密码文件
                echo "[client]" > /tmp/cron_mysql.cnf
                echo "password=$SERVER_PASSWORD" >> /tmp/cron_mysql.cnf
                chmod 600 /tmp/cron_mysql.cnf
                CRON_JOB="0 2 * * * mysqldump --defaults-extra-file=/tmp/cron_mysql.cnf -h$MYSQL_HOST -P$MYSQL_PORT -u$MYSQL_USER --single-transaction --routines --triggers --events $DATABASE_NAME | gzip > $BACKUP_DIR/${DATABASE_NAME}_\$(date +\\%Y\\%m\\%d_\\%H\\%M\\%S).sql.gz"
              else
                CRON_JOB="0 2 * * * mysqldump -h$MYSQL_HOST -P$MYSQL_PORT -u$MYSQL_USER --single-transaction --routines --triggers --events $DATABASE_NAME | gzip > $BACKUP_DIR/${DATABASE_NAME}_\$(date +\\%Y\\%m\\%d_\\%H\\%M\\%S).sql.gz"
              fi
              
              # 检查是否已存在定时任务
              if ! crontab -l 2>/dev/null | grep -q "$DATABASE_NAME"; then
                echo "⏰ 设置定时备份任务..."
                (crontab -l 2>/dev/null; echo "$CRON_JOB") | crontab -
                echo "✅ 定时备份任务已设置"
              else
                echo "📋 定时备份任务已存在"
              fi
            else
              echo "❌ 数据库备份失败"
              exit 1
            fi

      - name: 设置输出
        id: set-outputs
        run: |
          if [[ "${{ inputs.deploy_type }}" == "backend" ]]; then
            DEPLOY_PATH="/srv/apps/${{ inputs.project }}"
          else
            DEPLOY_PATH="/srv/static/${{ inputs.project }}"
          fi
          
          echo "deploy_success=true" >> $GITHUB_OUTPUT
          echo "deploy_path=$DEPLOY_PATH" >> $GITHUB_OUTPUT
          echo "✅ 输出已设置"
          echo "- deploy_success: true"
          echo "- deploy_path: $DEPLOY_PATH"
