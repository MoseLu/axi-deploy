name: Main Deployment

description: "主部署工作流 - 整个部署流程的入口点"

on:
  # 保留手动触发功能
  workflow_dispatch:
    inputs:
      project:
        description: '项目名称'
        required: true
        type: string
      source_repo:
        description: '源仓库 (格式: owner/repo)'
        required: true
        type: string
      run_id:
        description: '构建运行ID'
        required: true
        type: string
      deploy_type:
        description: '部署类型'
        required: true
        default: 'static'
        type: choice
        options:
          - static
          - backend
      nginx_config:
        description: 'Nginx配置（可选）'
        required: false
        type: string
      test_url:
        description: '测试URL（可选）'
        required: false
        type: string
      start_cmd:
        description: '启动命令（后端项目）'
        required: false
        type: string
      deploy_secrets:
        description: '部署密钥 (JSON格式或base64编码的JSON: {"SERVER_HOST":"host","SERVER_PORT":"port","SERVER_USER":"user","SERVER_KEY":"key","DEPLOY_CENTER_PAT":"pat"})'
        required: true
        type: string
      skip_init:
        description: '跳过服务器初始化步骤'
        required: false
        type: boolean
        default: false

jobs:
  # 步骤1: 服务器初始化（可选）
  server-init:
    runs-on: ubuntu-latest
    if: ${{ inputs.skip_init != 'true' }}
    steps:
      - name: 服务器初始化
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_KEY }}
          port: ${{ secrets.SERVER_PORT }}
          script: |
            echo "🚀 开始服务器初始化..."
            
            # 获取输入参数
            DOMAIN="redamancy.com.cn"
            RUN_USER="deploy"
            APPS_ROOT="/srv/apps"
            STATIC_ROOT="/srv/static"
            NGINX_CONF_DIR="/www/server/nginx/conf/conf.d/redamancy"
            CERT_SRC="/www/server/panel/vhost/cert/redamancy.com.cn"
            CERT_DST="/www/server/nginx/ssl/redamancy"
            
            echo "📋 初始化配置:"
            echo "- 域名: $DOMAIN"
            echo "- 运行用户: $RUN_USER"
            echo "- 应用目录: $APPS_ROOT"
            echo "- 静态目录: $STATIC_ROOT"
            echo "- Nginx配置: $NGINX_CONF_DIR"
            echo "- 证书源: $CERT_SRC"
            echo "- 证书目标: $CERT_DST"
            
            # 0. 前置检查
            echo "🔍 前置检查..."
            if ! command -v nginx &> /dev/null; then
              echo "❌ Nginx未安装，无法继续初始化"
              exit 1
            fi
            echo "✅ Nginx已安装: $(nginx -v)"
            
            # 1. 创建业务运行用户（灾后自愈）
            echo "👤 检查业务运行用户..."
            if ! id "$RUN_USER" &>/dev/null; then
              echo "🆕 创建用户 $RUN_USER..."
              sudo useradd -m -s /bin/bash $RUN_USER
              echo "✅ 用户 $RUN_USER 创建完成"
            else
              echo "✅ 用户 $RUN_USER 已存在"
            fi
            
            # 2. 创建所需目录（灾后自愈）
            echo "📁 检查并创建目录..."
            sudo mkdir -p $APPS_ROOT $STATIC_ROOT $NGINX_CONF_DIR $CERT_DST
            sudo chown $RUN_USER:$RUN_USER $APPS_ROOT $STATIC_ROOT
            sudo chmod 755 $NGINX_CONF_DIR $CERT_DST
            echo "✅ 目录结构检查完成"
            
            # 3. 软链宝塔证书（健康巡检）
            echo "🔗 检查证书软链..."
            if [ ! -d "$CERT_SRC" ]; then
              echo "❌ 证书源目录不存在: $CERT_SRC"
              echo "请确保宝塔面板已为域名 $DOMAIN 配置SSL证书"
              exit 1
            fi
            
            # 检查并重新创建软链
            if [ -f "$CERT_SRC/fullchain.pem" ]; then
              sudo ln -sf $CERT_SRC/fullchain.pem $CERT_DST/fullchain.pem
              echo "✅ 软链 fullchain.pem 完成"
            else
              echo "❌ 证书文件不存在: $CERT_SRC/fullchain.pem"
              exit 1
            fi
            
            if [ -f "$CERT_SRC/privkey.pem" ]; then
              sudo ln -sf $CERT_SRC/privkey.pem $CERT_DST/privkey.pem
              echo "✅ 软链 privkey.pem 完成"
            else
              echo "❌ 私钥文件不存在: $CERT_SRC/privkey.pem"
              exit 1
            fi
            
            # 4. 写入/更新主配置（配置变更）
            echo "📝 更新主配置文件..."
            MAIN_CONF="$NGINX_CONF_DIR/00-main.conf"
            
            # 创建主配置文件备份目录
            MAIN_BACKUP_DIR="$NGINX_CONF_DIR/backups/main"
            echo "📁 创建主配置文件备份目录: $MAIN_BACKUP_DIR"
            sudo mkdir -p "$MAIN_BACKUP_DIR"
            sudo chmod 755 "$MAIN_BACKUP_DIR"
            
            # 备份现有主配置文件（如果存在）
            if [ -f "$MAIN_CONF" ]; then
              echo "📋 备份现有主配置文件: $MAIN_CONF"
              MAIN_BACKUP_FILE="$MAIN_BACKUP_DIR/00-main.conf.backup.$(date +%Y%m%d_%H%M%S)"
              sudo cp "$MAIN_CONF" "$MAIN_BACKUP_FILE"
              echo "✅ 主配置文件已备份到: $MAIN_BACKUP_FILE"
            else
              echo "📋 主配置文件不存在，将创建新文件"
            fi
            
            # 检查是否需要重新生成配置
            if [ ! -f "$MAIN_CONF" ] || [ "$(grep -c 'location ~ \^/\(?!docs|api|health|uploads|static|\$\)' $MAIN_CONF 2>/dev/null || echo 0)" -gt 0 ]; then
              echo "🔄 重新生成主配置文件..."
              sudo tee $MAIN_CONF <<'EOF'
            server {
                listen 443 ssl;
                server_name redamancy.com.cn;
                http2 on;
            
                ssl_certificate     /www/server/nginx/ssl/redamancy/fullchain.pem;
                ssl_certificate_key /www/server/nginx/ssl/redamancy/privkey.pem;
            
                client_max_body_size 100m;
            
                # 这里自动加载 route-*.conf（项目路由）——主配置永远不用再改
                include /www/server/nginx/conf/conf.d/redamancy/route-*.conf;
            }
            
            server {
                listen 80;
                server_name redamancy.com.cn;
                
                # HTTP到HTTPS重定向
                return 301 https://$host$request_uri;
            }
            EOF
              echo "✅ 主配置文件已更新"
            else
              echo "✅ 主配置文件无需更新"
            fi
            
            # 5. 检查并重载Nginx（健康巡检）
            echo "🔄 检查Nginx配置..."
            if sudo nginx -t; then
              echo "✅ Nginx配置语法检查通过"
            else
              echo "❌ Nginx配置语法错误"
              echo "配置错误详情:"
              sudo nginx -t 2>&1
              exit 1
            fi
            
            echo "🔄 尝试重载Nginx..."
            if pgrep nginx > /dev/null; then
              echo "✅ Nginx进程正在运行，尝试重载..."
              if sudo systemctl reload nginx; then
                echo "✅ Nginx热加载完成"
              else
                echo "❌ Nginx重载失败，尝试重启..."
                if sudo systemctl restart nginx; then
                  echo "✅ Nginx重启成功"
                else
                  echo "❌ Nginx重启失败"
                  exit 1
                fi
              fi
            else
              echo "⚠️  Nginx进程未运行，尝试启动..."
              if sudo systemctl start nginx; then
                echo "✅ Nginx启动成功"
              else
                echo "❌ Nginx启动失败"
                exit 1
              fi
            fi
            
            echo "✅ 服务器初始化完成！"

  download-artifact:
    runs-on: ubuntu-latest
    needs: [server-init]
    if: always()
    outputs:
      artifact_path: ${{ steps.set-outputs.outputs.artifact_path }}
      artifact_size: ${{ steps.set-outputs.outputs.artifact_size }}
      artifact_name: ${{ steps.set-project-info.outputs.artifact_name }}
      project: ${{ steps.set-project-info.outputs.project }}
      source_repo: ${{ steps.set-project-info.outputs.source_repo }}
      run_id: ${{ steps.set-project-info.outputs.run_id }}
      server_host: ${{ steps.parse-secrets.outputs.server_host }}
      server_user: ${{ steps.parse-secrets.outputs.server_user }}
      server_key: ${{ steps.parse-secrets.outputs.server_key }}
      server_port: ${{ steps.parse-secrets.outputs.server_port }}
      deploy_center_pat: ${{ steps.parse-secrets.outputs.deploy_center_pat }}
    
    steps:
      - name: 解析部署密钥
        id: parse-secrets
        run: |
          echo "🔍 解析部署密钥..."
          
          # 从输入参数获取部署密钥
          DEPLOY_SECRETS='${{ inputs.deploy_secrets }}'
          
          # 检查是否为base64编码
          if echo "$DEPLOY_SECRETS" | base64 -d &>/dev/null; then
            echo "📦 检测到base64编码的部署密钥，正在解码..."
            DEPLOY_SECRETS=$(echo "$DEPLOY_SECRETS" | base64 -d)
          fi
          
          # 使用jq解析JSON配置
          SERVER_HOST=$(echo "$DEPLOY_SECRETS" | jq -r '.SERVER_HOST')
          SERVER_PORT=$(echo "$DEPLOY_SECRETS" | jq -r '.SERVER_PORT')
          SERVER_USER=$(echo "$DEPLOY_SECRETS" | jq -r '.SERVER_USER')
          SERVER_KEY=$(echo "$DEPLOY_SECRETS" | jq -r '.SERVER_KEY')
          DEPLOY_CENTER_PAT=$(echo "$DEPLOY_SECRETS" | jq -r '.DEPLOY_CENTER_PAT')
          
          # 验证必需参数
          if [ "$SERVER_HOST" = "null" ] || [ -z "$SERVER_HOST" ]; then
            echo "🚨 缺少必需的SERVER_HOST参数"
            exit 1
          fi
          if [ "$SERVER_PORT" = "null" ] || [ -z "$SERVER_PORT" ]; then
            echo "🚨 缺少必需的SERVER_PORT参数"
            exit 1
          fi
          if [ "$SERVER_USER" = "null" ] || [ -z "$SERVER_USER" ]; then
            echo "🚨 缺少必需的SERVER_USER参数"
            exit 1
          fi
          if [ "$SERVER_KEY" = "null" ] || [ -z "$SERVER_KEY" ]; then
            echo "🚨 缺少必需的SERVER_KEY参数"
            exit 1
          fi
          if [ "$DEPLOY_CENTER_PAT" = "null" ] || [ -z "$DEPLOY_CENTER_PAT" ]; then
            echo "🚨 缺少必需的DEPLOY_CENTER_PAT参数"
            exit 1
          fi
          
          # 设置输出 - 对于包含换行符的SERVER_KEY，使用多行输出语法
          echo "server_host=$SERVER_HOST" >> $GITHUB_OUTPUT
          echo "server_port=$SERVER_PORT" >> $GITHUB_OUTPUT
          echo "server_user=$SERVER_USER" >> $GITHUB_OUTPUT
          echo "deploy_center_pat=$DEPLOY_CENTER_PAT" >> $GITHUB_OUTPUT
          
          # 对于包含换行符的SERVER_KEY，使用多行输出语法
          {
            echo 'server_key<<EOF' >> $GITHUB_OUTPUT
            echo "$SERVER_KEY" >> $GITHUB_OUTPUT
            echo 'EOF' >> $GITHUB_OUTPUT
          }
          
          echo "✅ 部署密钥解析完成"
          echo "📋 服务器信息:"
          echo "- 主机: $SERVER_HOST"
          echo "- 端口: $SERVER_PORT"
          echo "- 用户: $SERVER_USER"

      - name: 设置项目信息
        id: set-project-info
        run: |
          echo "🔧 设置项目信息..."
          
          # 从输入参数获取项目信息
          PROJECT="${{ inputs.project }}"
          SOURCE_REPO="${{ inputs.source_repo }}"
          RUN_ID="${{ inputs.run_id }}"
          echo "📋 从workflow_dispatch输入获取项目信息:"
          echo "  项目名称: $PROJECT"
          echo "  源仓库: $SOURCE_REPO"
          echo "  运行ID: $RUN_ID"
          
          # 设置输出变量
          echo "project=$PROJECT" >> $GITHUB_OUTPUT
          echo "source_repo=$SOURCE_REPO" >> $GITHUB_OUTPUT
          echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT
          
          # 根据项目名称确定artifact名称
          ARTIFACT_NAME="dist-$PROJECT"
          echo "artifact_name=$ARTIFACT_NAME" >> $GITHUB_OUTPUT
          
          echo "✅ 项目信息设置完成"

      - name: 检出代码
        uses: actions/checkout@v4

      - name: 下载构建产物
        uses: actions/download-artifact@v4
        with:
          name: ${{ steps.set-project-info.outputs.artifact_name }}
          path: ./
          github-token: ${{ steps.parse-secrets.outputs.deploy_center_pat }}
          repository: ${{ inputs.source_repo }}
          run-id: ${{ inputs.run_id }}

      - name: 检查下载结果
        run: |
          echo "🔍 检查下载结果..."
          echo "下载退出码: $?"
          echo "当前目录: $(pwd)"
          echo "当前目录内容:"
          ls -la ./
          
          # 检查是否有构建产物文件
          if [ -d "./dist-${{ steps.set-project-info.outputs.project }}" ]; then
            echo "✅ dist-${{ steps.set-project-info.outputs.project }} 目录存在"
            echo "dist-${{ steps.set-project-info.outputs.project }} 目录内容:"
            ls -la "./dist-${{ steps.set-project-info.outputs.project }}/"
            echo "📊 文件数量:"
            find "./dist-${{ steps.set-project-info.outputs.project }}" -type f | wc -l
            echo "📁 前10个文件:"
            find "./dist-${{ steps.set-project-info.outputs.project }}" -type f | head -10
          elif [ -f "./dist-${{ steps.set-project-info.outputs.project }}.zip" ]; then
            echo "✅ 找到构建产物压缩包"
            echo "📦 压缩包大小:"
            ls -lh "./dist-${{ steps.set-project-info.outputs.project }}.zip"
            echo "🔧 解压构建产物..."
            unzip -q "./dist-${{ steps.set-project-info.outputs.project }}.zip"
            echo "📁 解压后内容:"
            ls -la ./
          elif [ -f "./index.html" ]; then
            echo "✅ 找到构建产物（直接在当前目录）"
            echo "📁 构建产物内容:"
            ls -la ./
            echo "📊 文件数量:"
            find . -type f -maxdepth 1 | wc -l
            echo "📁 前10个文件:"
            find . -type f -maxdepth 1 | head -10
          else
            echo "❌ 未找到构建产物"
            echo "🔍 所有文件:"
            find . -type f -maxdepth 1
            echo "🔍 所有目录:"
            find . -type d -maxdepth 2
            echo "🚨 工作流错误：未找到构建产物，终止部署"
            exit 1
          fi

      - name: 验证构建产物完整性
        run: |
          echo "🔍 验证构建产物完整性..."
          
          # 等待一下确保文件完全下载
          sleep 2
          
          # 检查可能的构建产物目录
          if [ -d "./dist-${{ steps.set-project-info.outputs.project }}" ]; then
            ARTIFACT_DIR="./dist-${{ steps.set-project-info.outputs.project }}"
            echo "📁 找到 dist-${{ steps.set-project-info.outputs.project }} 目录"
          elif [ -d "./dist" ]; then
            ARTIFACT_DIR="./dist"
            echo "📁 找到 dist 目录"
          elif [ -d "./docs/.vitepress/dist" ]; then
            ARTIFACT_DIR="./docs/.vitepress/dist"
            echo "📁 找到 docs/.vitepress/dist 目录"
          elif [ -d "./.vitepress/dist" ]; then
            ARTIFACT_DIR="./.vitepress/dist"
            echo "📁 找到 .vitepress/dist 目录"
          elif [ -f "./index.html" ]; then
            # 构建产物直接在当前目录
            ARTIFACT_DIR="."
            echo "📁 构建产物直接在当前目录"
          else
            echo "❌ 未找到构建产物目录"
            echo "🔍 当前目录内容:"
            ls -la ./
            echo "🔍 所有子目录:"
            find . -type d -maxdepth 2
            echo "🔍 所有文件:"
            find . -type f -maxdepth 2
            exit 1
          fi
          
          echo "📁 构建产物目录: $ARTIFACT_DIR"
          echo "📁 构建产物目录内容:"
          ls -la "$ARTIFACT_DIR/"
          
          # 检查是否有文件
          FILE_COUNT=$(find "$ARTIFACT_DIR" -type f | wc -l)
          echo "📊 文件数量: $FILE_COUNT"
          
          if [ "$FILE_COUNT" -eq 0 ]; then
            echo "❌ 构建产物目录为空"
            echo "🔍 调试信息:"
            echo "当前目录内容:"
            ls -la ./
            echo "所有子目录:"
            find . -type d -maxdepth 2
            echo "所有文件:"
            find . -type f -maxdepth 2
            echo "🚨 工作流错误：构建产物解压后为空，立即终止部署"
            echo "可能的原因:"
            echo "1. 构建产物下载失败"
            echo "2. 构建产物解压失败"
            echo "3. 构建产物本身为空"
            echo "4. 文件权限问题"
            exit 1
          fi
          
          # 检查关键文件是否存在
          if [ -f "$ARTIFACT_DIR/index.html" ]; then
            echo "✅ 找到 index.html 文件"
          else
            echo "⚠️ 未找到 index.html 文件"
            echo "📁 构建产物中的文件:"
            find "$ARTIFACT_DIR" -type f | head -20
          fi
          
          echo "✅ 构建产物验证通过"
          echo "📊 文件数量: $FILE_COUNT"

      - name: 设置输出
        id: set-outputs
        run: |
          echo "🔍 确定构建产物路径..."
          echo "当前目录内容:"
          ls -la ./
          
          # 确定构建产物路径
          if [ -d "./dist-${{ steps.set-project-info.outputs.project }}" ]; then
            ARTIFACT_PATH="./dist-${{ steps.set-project-info.outputs.project }}"
            echo "📁 找到 dist-${{ steps.set-project-info.outputs.project }} 目录"
          elif [ -d "./dist" ]; then
            ARTIFACT_PATH="./dist"
            echo "📁 找到 dist 目录"
          elif [ -d "./docs/.vitepress/dist" ]; then
            ARTIFACT_PATH="./docs/.vitepress/dist"
            echo "📁 找到 docs/.vitepress/dist 目录"
          elif [ -f "./index.html" ]; then
            # 构建产物直接在当前目录
            ARTIFACT_PATH="."
            echo "📁 构建产物直接在当前目录"
          else
            echo "❌ 未找到构建产物路径"
            echo "🔍 当前目录内容:"
            ls -la ./
            echo "🔍 所有子目录:"
            find . -type d -maxdepth 2
            echo "🔍 所有文件:"
            find . -type f -maxdepth 2
            exit 1
          fi
          
          echo "📁 最终构建产物路径: $ARTIFACT_PATH"
          echo "📁 构建产物内容:"
          ls -la "$ARTIFACT_PATH/"
          
          # 最终验证：确保构建产物不为空
          FINAL_FILE_COUNT=$(find "$ARTIFACT_PATH" -type f | wc -l)
          if [ "$FINAL_FILE_COUNT" -eq 0 ]; then
            echo "🚨 最终验证失败：构建产物为空"
            exit 1
          fi
          
          echo "artifact_path=$ARTIFACT_PATH" >> $GITHUB_OUTPUT
          echo "artifact_size=$(du -sb $ARTIFACT_PATH | cut -f1)" >> $GITHUB_OUTPUT
          echo "✅ 输出已设置"
          echo "构建产物路径: $ARTIFACT_PATH"
          echo "构建产物大小: $(du -sh $ARTIFACT_PATH | cut -f1)"

  deploy-project:
    needs: [download-artifact]
    runs-on: ubuntu-latest
    outputs:
      deploy_success: ${{ steps.set-outputs.outputs.deploy_success }}
      deploy_path: ${{ steps.set-outputs.outputs.deploy_path }}
    
    steps:
      - name: 下载构建产物
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.download-artifact.outputs.artifact_name }}
          path: ./
          github-token: ${{ needs.download-artifact.outputs.deploy_center_pat }}

      - name: 验证构建产物路径
        id: validate-artifact
        run: |
          echo "🔍 验证构建产物路径..."
          echo "当前工作目录: $(pwd)"
          echo "构建产物路径: ${{ needs.download-artifact.outputs.artifact_path }}"
          echo "构建产物大小: ${{ needs.download-artifact.outputs.artifact_size }}"
          
          # 确定构建产物路径
          if [ -d "./dist-${{ needs.download-artifact.outputs.project }}" ]; then
            ARTIFACT_PATH="./dist-${{ needs.download-artifact.outputs.project }}"
            echo "📁 找到 dist-${{ needs.download-artifact.outputs.project }} 目录"
          elif [ -d "./dist" ]; then
            ARTIFACT_PATH="./dist"
            echo "📁 找到 dist 目录"
          elif [ -d "./docs/.vitepress/dist" ]; then
            ARTIFACT_PATH="./docs/.vitepress/dist"
            echo "📁 找到 docs/.vitepress/dist 目录"
          elif [ -f "./index.html" ]; then
            # 构建产物直接在当前目录
            ARTIFACT_PATH="."
            echo "📁 构建产物直接在当前目录"
          else
            echo "❌ 未找到构建产物路径"
            echo "🔍 当前目录内容:"
            ls -la ./
            echo "🔍 所有子目录:"
            find . -type d -maxdepth 2
            echo "🔍 所有文件:"
            find . -type f -maxdepth 2
            exit 1
          fi
          
          if [ -z "$ARTIFACT_PATH" ]; then
            echo "🚨 构建产物路径为空，终止部署"
            exit 1
          fi
          
          if [ ! -d "$ARTIFACT_PATH" ] && [ ! -f "$ARTIFACT_PATH/index.html" ]; then
            echo "🚨 构建产物目录不存在: $ARTIFACT_PATH"
            exit 1
          fi
          
          echo "📁 构建产物目录内容:"
          ls -la "$ARTIFACT_PATH/"
          
          # 验证文件数量
          FILE_COUNT=$(find "$ARTIFACT_PATH" -type f | wc -l)
          echo "📊 文件数量: $FILE_COUNT"
          
          if [ "$FILE_COUNT" -eq 0 ]; then
            echo "🚨 构建产物目录为空，终止部署"
            exit 1
          fi
          
          echo "✅ 构建产物验证通过"
          echo "📁 最终构建产物路径: $ARTIFACT_PATH"
          
          # 设置输出
          echo "artifact_path=$ARTIFACT_PATH" >> $GITHUB_OUTPUT

      - name: 备份现有部署
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ needs.download-artifact.outputs.server_host }}
          username: ${{ needs.download-artifact.outputs.server_user }}
          key: ${{ needs.download-artifact.outputs.server_key }}
          port: ${{ needs.download-artifact.outputs.server_port }}
          script: |
            echo "📋 备份现有部署..."
            
            PROJECT="${{ needs.download-artifact.outputs.project }}"
            DEPLOY_TYPE="${{ inputs.deploy_type }}"
            DEPLOY_PATH="/srv/${{ inputs.deploy_type == 'backend' && 'apps' || 'static' }}/$PROJECT"
            
            # 创建项目专用备份目录
            if [[ "$DEPLOY_TYPE" == "backend" ]]; then
              BACKUP_ROOT="/srv/backups/apps"
            else
              BACKUP_ROOT="/srv/backups/static"
            fi
            PROJECT_BACKUP_DIR="$BACKUP_ROOT/$PROJECT"
            echo "📁 创建项目备份目录: $PROJECT_BACKUP_DIR"
            sudo mkdir -p "$PROJECT_BACKUP_DIR"
            sudo chmod 755 "$PROJECT_BACKUP_DIR"
            
            # 备份现有部署目录（如果存在）
            if [ -d "$DEPLOY_PATH" ]; then
              echo "📋 备份现有部署目录: $DEPLOY_PATH"
              BACKUP_NAME="$PROJECT_BACKUP_DIR/$PROJECT.backup.$(date +%Y%m%d_%H%M%S)"
              sudo cp -r $DEPLOY_PATH $BACKUP_NAME
              echo "✅ 现有部署目录已备份到: $BACKUP_NAME"
              
              # 清理旧的备份文件，只保留最近2个
              echo "🧹 清理旧的备份文件..."
              BACKUP_FILES=$(ls -t "$PROJECT_BACKUP_DIR"/$PROJECT.backup.* 2>/dev/null | tail -n +3)
              if [ -n "$BACKUP_FILES" ]; then
                echo "🗑️ 删除旧的备份文件:"
                echo "$BACKUP_FILES" | xargs -r sudo rm -rf
                echo "✅ 旧备份文件已清理，保留最近2个备份"
              else
                echo "📋 没有需要清理的旧备份文件"
              fi
            else
              echo "📋 部署目录不存在，无需备份: $DEPLOY_PATH"
            fi

      - name: 直接部署到目标目录
        uses: appleboy/scp-action@v0.1.7
        with:
          host:     ${{ needs.download-artifact.outputs.server_host }}
          username: ${{ needs.download-artifact.outputs.server_user }}
          key:      ${{ needs.download-artifact.outputs.server_key }}
          port:     ${{ needs.download-artifact.outputs.server_port }}
          source:   "${{ needs.download-artifact.outputs.artifact_path }}"
          target:   "/srv/${{ inputs.deploy_type == 'backend' && 'apps' || 'static' }}/${{ needs.download-artifact.outputs.project }}"
          strip_components: 0

      - name: 验证部署结果
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ needs.download-artifact.outputs.server_host }}
          username: ${{ needs.download-artifact.outputs.server_user }}
          key: ${{ needs.download-artifact.outputs.server_key }}
          port: ${{ needs.download-artifact.outputs.server_port }}
          script: |
            echo "🔍 验证部署结果..."
            
            PROJECT="${{ needs.download-artifact.outputs.project }}"
            DEPLOY_TYPE="${{ inputs.deploy_type }}"
            DEPLOY_PATH="/srv/${{ inputs.deploy_type == 'backend' && 'apps' || 'static' }}/$PROJECT"
            
            echo "📁 检查部署目录: $DEPLOY_PATH"
            
            if [ ! -d "$DEPLOY_PATH" ]; then
              echo "🚨 部署目录不存在: $DEPLOY_PATH"
              exit 1
            fi
            
            echo "📁 部署目录内容:"
            ls -la "$DEPLOY_PATH/"
            
            # 检查文件数量
            FILE_COUNT=$(find "$DEPLOY_PATH" -type f | wc -l)
            echo "📊 文件数量: $FILE_COUNT"
            
            if [ "$FILE_COUNT" -eq 0 ]; then
              echo "🚨 部署目录为空，部署失败"
              echo "🔍 调试信息:"
              echo "部署路径: $DEPLOY_PATH"
              echo "目录是否存在: $(test -d "$DEPLOY_PATH" && echo '是' || echo '否')"
              echo "目录权限: $(ls -ld "$DEPLOY_PATH" 2>/dev/null || echo '无法获取权限')"
              exit 1
            fi
            
            # 检查是否有 index.html 文件
            if [ -f "$DEPLOY_PATH/index.html" ]; then
              echo "✅ 找到 index.html 文件"
              echo "📄 index.html 内容预览:"
              head -10 "$DEPLOY_PATH/index.html"
            else
              echo "⚠️ 未找到 index.html 文件"
              echo "🔍 检查所有文件:"
              find "$DEPLOY_PATH" -type f | head -10
            fi
            
            echo "✅ 部署验证通过"

      - name: 整理部署目录结构
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ needs.download-artifact.outputs.server_host }}
          username: ${{ needs.download-artifact.outputs.server_user }}
          key: ${{ needs.download-artifact.outputs.server_key }}
          port: ${{ needs.download-artifact.outputs.server_port }}
          script: |
            echo "📁 整理部署目录结构..."
            
            PROJECT="${{ needs.download-artifact.outputs.project }}"
            DEPLOY_TYPE="${{ inputs.deploy_type }}"
            DEPLOY_PATH="/srv/${{ inputs.deploy_type == 'backend' && 'apps' || 'static' }}/$PROJECT"
            
            echo "📁 检查部署目录: $DEPLOY_PATH"
            ls -la "$DEPLOY_PATH/"
            
            # 检查是否有 index.html 文件
            if [ -f "$DEPLOY_PATH/index.html" ]; then
              echo "✅ 找到 index.html 文件"
              echo "📄 index.html 内容预览:"
              head -10 "$DEPLOY_PATH/index.html"
            else
              echo "❌ 未找到 index.html 文件"
              echo "🔍 检查所有文件:"
              find "$DEPLOY_PATH" -type f | head -10
            fi
            
            # 如果存在嵌套的github/workspace目录，需要移动文件
            if [ -d "$DEPLOY_PATH/github/workspace" ]; then
              echo "📁 发现嵌套目录结构，正在整理..."
              
              # 创建临时目录
              TEMP_DIR="/tmp/deploy-$PROJECT-temp"
              sudo mkdir -p "$TEMP_DIR"
              
              # 移动所有文件到临时目录
              sudo mv "$DEPLOY_PATH/github/workspace"/* "$TEMP_DIR/" 2>/dev/null || true
              
              # 删除原始目录
              sudo rm -rf "$DEPLOY_PATH"
              
              # 重新创建部署目录
              sudo mkdir -p "$DEPLOY_PATH"
              
              # 移动文件到正确位置
              sudo mv "$TEMP_DIR"/* "$DEPLOY_PATH/" 2>/dev/null || true
              
              # 清理临时目录
              sudo rm -rf "$TEMP_DIR"
              
              echo "✅ 目录结构整理完成"
            elif [ -d "$DEPLOY_PATH/github" ]; then
              echo "📁 发现github目录，正在整理..."
              
              # 创建临时目录
              TEMP_DIR="/tmp/deploy-$PROJECT-temp"
              sudo mkdir -p "$TEMP_DIR"
              
              # 移动所有文件到临时目录
              sudo mv "$DEPLOY_PATH/github"/* "$TEMP_DIR/" 2>/dev/null || true
              
              # 删除原始目录
              sudo rm -rf "$DEPLOY_PATH"
              
              # 重新创建部署目录
              sudo mkdir -p "$DEPLOY_PATH"
              
              # 移动文件到正确位置
              sudo mv "$TEMP_DIR"/* "$DEPLOY_PATH/" 2>/dev/null || true
              
              # 清理临时目录
              sudo rm -rf "$TEMP_DIR"
              
              echo "✅ 目录结构整理完成"
            else
              echo "✅ 目录结构正常，无需整理"
            fi
            
            echo "📁 最终部署目录内容:"
            ls -la "$DEPLOY_PATH/"
            
            # 最终验证：确保整理后的目录不为空
            FINAL_FILE_COUNT=$(find "$DEPLOY_PATH" -type f | wc -l)
            if [ "$FINAL_FILE_COUNT" -eq 0 ]; then
              echo "🚨 整理后部署目录为空，部署失败"
              exit 1
            fi
            
            echo "✅ 目录整理完成，文件数量: $FINAL_FILE_COUNT"
            
            # 设置正确的权限
            sudo chown -R deploy:deploy "$DEPLOY_PATH"
            sudo chmod -R 755 "$DEPLOY_PATH"

      - name: 设置输出
        id: set-outputs
        run: |
          echo "deploy_success=true" >> $GITHUB_OUTPUT
          echo "deploy_path=/srv/${{ inputs.deploy_type == 'backend' && 'apps' || 'static' }}/${{ needs.download-artifact.outputs.project }}" >> $GITHUB_OUTPUT
          echo "✅ 部署完成"

  configure-nginx:
    needs: [deploy-project]
    if: ${{ inputs.nginx_config != '' }}
    uses: MoseLu/axi-deploy/.github/workflows/configure-nginx.yml@master
    with:
      project: ${{ needs.download-artifact.outputs.project }}
      server_host: ${{ needs.download-artifact.outputs.server_host }}
      server_user: ${{ needs.download-artifact.outputs.server_user }}
      server_key: ${{ needs.download-artifact.outputs.server_key }}
      server_port: ${{ needs.download-artifact.outputs.server_port }}
      deploy_type: ${{ inputs.deploy_type }}
      nginx_config: ${{ inputs.nginx_config }}

  start-service:
    needs: [deploy-project]
    if: ${{ inputs.start_cmd != '' && inputs.deploy_type == 'backend' }}
    runs-on: ubuntu-latest
    outputs:
      start_success: ${{ steps.set-outputs.outputs.start_success }}
    
    steps:
      - name: 启动服务
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ needs.download-artifact.outputs.server_host }}
          username: ${{ needs.download-artifact.outputs.server_user }}
          key: ${{ needs.download-artifact.outputs.server_key }}
          port: ${{ needs.download-artifact.outputs.server_port }}
          script: |
            echo "🚀 启动服务..."
            
            PROJECT="${{ needs.download-artifact.outputs.project }}"
            START_CMD="${{ inputs.start_cmd }}"
            APPS_ROOT="/srv/apps"
            
            # 切换到项目目录
            cd "$APPS_ROOT/$PROJECT"
            
            # 验证项目目录是否存在
            if [ ! -d "$APPS_ROOT/$PROJECT" ]; then
              echo "🚨 项目目录不存在: $APPS_ROOT/$PROJECT"
              exit 1
            fi
            
            # 验证项目目录不为空
            FILE_COUNT=$(find "$APPS_ROOT/$PROJECT" -type f | wc -l)
            if [ "$FILE_COUNT" -eq 0 ]; then
              echo "🚨 项目目录为空: $APPS_ROOT/$PROJECT"
              exit 1
            fi
            
            echo "✅ 项目目录验证通过，文件数量: $FILE_COUNT"
            
            # 执行启动命令
            echo "📋 执行启动命令: $START_CMD"
            $START_CMD
            
            # 等待服务启动
            sleep 5
            
            echo "✅ 服务启动完成"

      - name: 设置输出
        id: set-outputs
        run: |
          echo "start_success=true" >> $GITHUB_OUTPUT
          echo "✅ 启动完成"

  test-website:
    needs: [deploy-project, configure-nginx, start-service]
    if: ${{ inputs.test_url != '' }}
    runs-on: ubuntu-latest
    outputs:
      test_success: ${{ steps.set-outputs.outputs.test_success }}
    
    steps:
      - name: 测试网站可访问性
        run: |
          echo "🔍 测试网站可访问性..."
          echo "测试URL: ${{ inputs.test_url }}"
          
          # 等待一段时间让服务完全启动
          sleep 10
          
          # 测试网站可访问性
          HTTP_STATUS=$(curl -f -s -o /dev/null -w "%{http_code}" "${{ inputs.test_url }}" 2>/dev/null || echo "000")
          echo "📋 HTTP状态码: $HTTP_STATUS"
          
          if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "301" ] || [ "$HTTP_STATUS" = "302" ]; then
            echo "✅ 网站可正常访问"
          else
            echo "❌ 网站无法访问，HTTP状态码: $HTTP_STATUS"
            echo "🚨 工作流错误：网站返回 $HTTP_STATUS 状态码，这表示配置有问题"
            echo "可能的原因:"
            echo "1. Nginx配置错误"
            echo "2. 文件权限问题"
            echo "3. 路径不存在"
            echo "4. SSL证书问题"
            exit 1
          fi

      - name: 设置输出
        id: set-outputs
        run: |
          echo "test_success=true" >> $GITHUB_OUTPUT
          echo "✅ 测试完成"

  deployment-summary:
    needs: [download-artifact, deploy-project, configure-nginx, start-service, test-website]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: 部署完成总结
        run: |
          echo "🎉 部署流程完成"
          echo "=========================================="
          echo "📋 部署信息:"
          echo "- 项目: ${{ needs.download-artifact.outputs.project }}"
          echo "- 部署类型: ${{ inputs.deploy_type }}"
          echo "- 源仓库: ${{ needs.download-artifact.outputs.source_repo }}"
          echo "- 构建ID: ${{ needs.download-artifact.outputs.run_id }}"
          echo ""
          echo "📊 执行状态:"
          echo "- 下载构建产物: ${{ needs.download-artifact.result }}"
          echo "- 部署项目: ${{ needs.deploy-project.result }}"
          echo "- 配置Nginx: ${{ needs.configure-nginx.result || 'skipped' }}"
          echo "- 启动服务: ${{ needs.start-service.result || 'skipped' }}"
          echo "- 测试网站: ${{ needs.test-website.result || 'skipped' }}"
          echo ""
          echo "🔗 访问信息:"
          echo "- 域名: redamancy.com.cn"
          echo "- 项目路径: ${{ needs.deploy-project.outputs.deploy_path }}"
          if [ "${{ inputs.test_url }}" != "" ]; then
            echo "- 测试URL: ${{ inputs.test_url }}"
          fi
          echo ""
          echo "📝 部署完成通知:"
          echo "✅ 项目 ${{ needs.download-artifact.outputs.project }} 已成功部署到服务器"
          if [ "${{ inputs.test_url }}" != "" ]; then
            echo "🌐 可通过 ${{ inputs.test_url }} 访问"
          fi
          echo "=========================================="