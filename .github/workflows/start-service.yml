name: Start Service

on:
  workflow_call:
    inputs:
      project:
        required: true
        type: string
        description: "项目名称"
      start_cmd:
        required: false
        type: string
        description: "启动命令"
        default: ""
      deploy_type:
        required: true
        type: string
        description: "部署类型 (backend/static)"
        default: "static"
      server_host:
        required: true
        type: string
        description: "服务器地址"
      server_user:
        required: true
        type: string
        description: "服务器用户"
      server_key:
        required: true
        type: string
        description: "服务器密钥"
      server_port:
        required: true
        type: string
        description: "服务器端口"
      apps_root:
        required: false
        type: string
        description: "应用目录路径"
        default: "/srv/apps"
    outputs:
      start_success:
        description: "启动是否成功"
        value: ${{ jobs.start.outputs.start_success }}

jobs:
  start:
    runs-on: ubuntu-latest
    timeout-minutes: 15  # 启动服务超时时间
    outputs:
      start_success: ${{ steps.set-outputs.outputs.start_success }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: 验证输入参数
        run: |
          echo "🔍 验证输入参数..."
          echo "- 项目: ${{ inputs.project }}"
          echo "- 部署类型: ${{ inputs.deploy_type }}"
          echo "- 启动命令: ${{ inputs.start_cmd }}"
          echo "- 服务器: ${{ inputs.server_host }}:${{ inputs.server_port }}"
          echo "- 用户: ${{ inputs.server_user }}"
          
          if [ "${{ inputs.deploy_type }}" != "backend" ]; then
            echo "⚠️ 非后端项目，跳过启动命令"
            echo "start_success=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          if [ -z "${{ inputs.start_cmd }}" ]; then
            echo "⚠️ 未提供启动命令，跳过启动步骤"
            echo "start_success=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "✅ 输入参数验证通过"

      - name: 使用重试机制启动服务
        id: start-service
        run: |
          # 重试中心核心逻辑
          MAX_RETRIES=3
          RETRY_DELAY=10
          TIMEOUT_MINUTES=15
          STRATEGY="exponential"
          STEP_NAME="启动服务"
          CONTINUE_ON_ERROR=false
          NOTIFY_ON_FAILURE=true
          STEP_TYPE="network"
          
          # 初始化变量
          ATTEMPTS=0
          SUCCESS=false
          ERROR_MESSAGE=""
          START_TIME=$(date +%s)
          
          echo "🚀 开始执行启动服务重试逻辑"
          echo "步骤名称: $STEP_NAME"
          echo "最大重试次数: $MAX_RETRIES"
          echo "重试间隔: $RETRY_DELAY秒"
          echo "超时时间: $TIMEOUT_MINUTES分钟"
          echo "重试策略: $STRATEGY"
          echo "步骤类型: $STEP_TYPE"
          
          # 重试逻辑
          while [ $ATTEMPTS -le $MAX_RETRIES ]; do
            ATTEMPTS=$((ATTEMPTS + 1))
            echo ""
            echo "🔄 第 $ATTEMPTS 次尝试启动服务..."
            
            # 设置超时
            TIMEOUT_CMD="timeout ${TIMEOUT_MINUTES}m"
            
            # 执行启动服务命令
            if $TIMEOUT_CMD bash -c "
              # 创建SSH密钥文件
              echo '${{ inputs.server_key }}' > /tmp/ssh_key
              chmod 600 /tmp/ssh_key
              
              # 创建启动脚本
              cat > /tmp/start_service_script.sh << 'EOF'
              #!/bin/bash
              set -e
              
              echo '🚀 执行启动命令...'
              echo '- 项目: ${{ inputs.project }}'
              echo '- 启动命令: ${{ inputs.start_cmd }}'
              
              # 切换到项目目录
              cd ${{ inputs.apps_root }}/${{ inputs.project }}
              echo '📁 当前目录: \$(pwd)'
              
              # 验证项目目录是否存在
              if [ ! -d '${{ inputs.apps_root }}/${{ inputs.project }}' ]; then
                echo '🚨 项目目录不存在: ${{ inputs.apps_root }}/${{ inputs.project }}'
                exit 1
              fi
              
              # 验证项目目录不为空
              FILE_COUNT=\$(find '${{ inputs.apps_root }}/${{ inputs.project }}' -type f | wc -l)
              if [ \"\$FILE_COUNT\" -eq 0 ]; then
                echo '🚨 项目目录为空: ${{ inputs.apps_root }}/${{ inputs.project }}'
                exit 1
              fi
              
              echo '✅ 项目目录验证通过，文件数量: \$FILE_COUNT'
              
              # 检查启动命令是否存在
              START_CMD='${{ inputs.start_cmd }}'
              CMD_NAME=\$(echo \"\$START_CMD\" | awk '{print \$1}')
              
              # 检查是否有 ecosystem.config.js 文件（PM2 项目）
              if [ -f 'ecosystem.config.js' ]; then
                echo '📋 发现 PM2 配置文件，使用 PM2 启动...'
                
                # 检查 PM2 是否安装
                if ! command -v pm2 &> /dev/null; then
                  echo '🚨 PM2 未安装，尝试安装...'
                  npm install -g pm2 || echo 'PM2 安装失败'
                fi
                
                # 停止现有进程（如果存在）
                pm2 stop dashboard-backend 2>/dev/null || echo '没有现有进程需要停止'
                pm2 delete dashboard-backend 2>/dev/null || echo '没有现有进程需要删除'
                
                # 使用 PM2 启动
                echo '📋 使用 PM2 启动服务...'
                pm2 start ecosystem.config.js
                
                # 保存 PM2 配置
                pm2 save
                
                echo '✅ PM2 启动命令执行完成'
                START_PID=\$(pm2 pid dashboard-backend 2>/dev/null || echo '0')
              else
                # 传统启动方式
                if ! command -v \"\$CMD_NAME\" &> /dev/null; then
                  echo '⚠️ 启动命令不存在: \$CMD_NAME'
                  echo '🔍 尝试查找可执行文件...'
                  which \"\$CMD_NAME\" || echo '未找到可执行文件'
                fi
                
                # 执行启动命令
                echo '📋 执行启动命令: \$START_CMD'
                \$START_CMD &
                START_PID=\$!
              fi
              
              # 等待服务启动
              echo '⏳ 等待服务启动...'
              sleep 5
              
              # 检查进程是否还在运行
              if kill -0 \$START_PID 2>/dev/null; then
                echo '✅ 启动命令执行成功，进程ID: \$START_PID'
              else
                echo '⚠️ 启动命令可能已结束，检查服务状态...'
              fi
              
              # 检查服务状态（如果可能）
              echo '📋 检查服务状态...'
              if command -v systemctl &> /dev/null; then
                SERVICE_NAME='${{ inputs.project }}'
                if systemctl is-active --quiet \$SERVICE_NAME; then
                  echo '✅ 服务 \$SERVICE_NAME 正在运行'
                else
                  echo '⚠️ 服务 \$SERVICE_NAME 未运行或无法检查'
                  # 尝试检查进程
                  if pgrep -f '${{ inputs.project }}' > /dev/null; then
                    echo '✅ 找到相关进程:'
                    pgrep -f '${{ inputs.project }}' | head -5
                  else
                    echo '⚠️ 未找到相关进程'
                  fi
                fi
              else
                echo '⚠️ 无法检查服务状态（systemctl不可用）'
                # 尝试检查进程
                if pgrep -f '${{ inputs.project }}' > /dev/null; then
                  echo '✅ 找到相关进程:'
                  pgrep -f '${{ inputs.project }}' | head -5
                else
                  echo '⚠️ 未找到相关进程'
                fi
              fi
              
              # 检查端口是否被占用（如果是后端服务）
              if command -v netstat &> /dev/null; then
                echo '🔍 检查端口占用情况...'
                netstat -tlnp | grep -E ':(8080|3000|8000|5000)' | head -5 || echo '未找到相关端口'
              fi
              
              echo '✅ 启动命令执行完成'
              
              # 服务启动验证
              echo '🔍 开始服务启动验证...'
              
              # 等待更长时间确保服务完全启动
              echo '⏳ 等待服务完全启动...'
              sleep 10
              
              # 检查服务健康状态
              echo '🏥 检查服务健康状态...'
              if command -v curl &> /dev/null; then
                # 尝试访问健康检查端点
                for port in 8080 3000 8000 5000; do
                  if curl -f -s http://localhost:\$port/health > /dev/null 2>&1; then
                    echo '✅ 服务在端口 \$port 上响应健康检查'
                    break
                  elif curl -f -s http://localhost:\$port/ > /dev/null 2>&1; then
                    echo '✅ 服务在端口 \$port 上响应'
                    break
                  fi
                done
              fi
              
              # 最终状态检查
              if pgrep -f '${{ inputs.project }}' > /dev/null || pm2 list | grep -q '${{ inputs.project }}'; then
                echo '✅ 服务启动成功！'
              else
                echo '⚠️ 服务可能未正常启动，但启动命令执行完成'
              fi
              
              echo '✅ 启动服务完成！'
              EOF
              
              # 使用SSH执行启动脚本
              ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 -o ServerAliveInterval=60 -o ServerAliveCountMax=3 -i /tmp/ssh_key -p ${{ inputs.server_port }} ${{ inputs.server_user }}@${{ inputs.server_host }} 'bash -s' < /tmp/start_service_script.sh
            "; then
              SUCCESS=true
              echo "✅ 启动服务成功！"
              break
            else
              EXIT_CODE=$?
              if [ $EXIT_CODE -eq 124 ]; then
                ERROR_MESSAGE="启动服务超时（${TIMEOUT_MINUTES}分钟）"
              else
                ERROR_MESSAGE="启动服务失败，退出码: $EXIT_CODE"
              fi
              
              echo "❌ 启动服务失败: $ERROR_MESSAGE"
              
              # 检查是否还有重试机会
              if [ $ATTEMPTS -le $MAX_RETRIES ]; then
                # 计算重试延迟
                if [ "$STRATEGY" = "exponential" ]; then
                  DELAY=$((RETRY_DELAY * (2 ** (ATTEMPTS - 1))))
                elif [ "$STRATEGY" = "adaptive" ]; then
                  DELAY=$((RETRY_DELAY + ATTEMPTS * 2))
                else
                  DELAY=$RETRY_DELAY
                fi
                
                echo "⏳ 等待 $DELAY 秒后重试..."
                sleep $DELAY
              fi
            fi
          done
          
          # 计算执行时间
          END_TIME=$(date +%s)
          EXECUTION_TIME=$((END_TIME - START_TIME))
          
          # 设置输出
          echo "success=$SUCCESS" >> $GITHUB_OUTPUT
          echo "attempts=$ATTEMPTS" >> $GITHUB_OUTPUT
          echo "execution_time=$EXECUTION_TIME" >> $GITHUB_OUTPUT
          echo "error_message=$ERROR_MESSAGE" >> $GITHUB_OUTPUT
          
          # 最终结果
          if [ "$SUCCESS" = "true" ]; then
            echo "🎉 启动服务重试逻辑执行完成 - 成功"
          else
            echo "💥 启动服务重试逻辑执行完成 - 失败"
            if [ "$CONTINUE_ON_ERROR" = "false" ]; then
              exit 1
            fi
          fi

      - name: 设置输出
        id: set-outputs
        run: |
          echo "start_success=true" >> $GITHUB_OUTPUT
          echo "✅ 启动服务完成"
