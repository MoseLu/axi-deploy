name: Start Service

on:
  workflow_call:
    inputs:
      project:
        required: true
        type: string
        description: "项目名称"
      start_cmd:
        required: false
        type: string
        description: "启动命令"
        default: ""
      deploy_type:
        required: true
        type: string
        description: "部署类型 (backend/static)"
        default: "static"
      server_host:
        required: true
        type: string
        description: "服务器地址"
      server_user:
        required: true
        type: string
        description: "服务器用户"
      server_key:
        required: true
        type: string
        description: "服务器密钥"
      server_port:
        required: true
        type: string
        description: "服务器端口"
      apps_root:
        required: false
        type: string
        description: "应用目录路径"
        default: "/srv/apps"
    outputs:
      start_success:
        description: "启动是否成功"
        value: ${{ jobs.start.outputs.start_success }}

jobs:
  start:
    runs-on: ubuntu-latest
    timeout-minutes: 15  # 启动服务超时时间
    outputs:
      start_success: ${{ steps.set-outputs.outputs.start_success }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: 验证输入参数
        run: |
          echo "🔍 验证输入参数..."
          echo "- 项目: ${{ inputs.project }}"
          echo "- 部署类型: ${{ inputs.deploy_type }}"
          echo "- 启动命令: ${{ inputs.start_cmd }}"
          echo "- 服务器: ${{ inputs.server_host }}:${{ inputs.server_port }}"
          echo "- 用户: ${{ inputs.server_user }}"
          
          if [ "${{ inputs.deploy_type }}" != "backend" ]; then
            echo "⚠️ 非后端项目，跳过启动命令"
            echo "start_success=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          if [ -z "${{ inputs.start_cmd }}" ]; then
            echo "⚠️ 未提供启动命令，跳过启动步骤"
            echo "start_success=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "✅ 输入参数验证通过"

      - name: 使用重试中心启动服务
        uses: ./.github/workflows/retry-center.yml
        with:
          step_name: "启动服务"
          command: |
            # 创建SSH密钥文件
            echo "${{ inputs.server_key }}" > /tmp/ssh_key
            chmod 600 /tmp/ssh_key
            
            # 创建启动脚本
            cat > /tmp/start_service_script.sh << 'EOF'
            #!/bin/bash
            set -e
            
            echo "🚀 执行启动命令..."
            echo "- 项目: ${{ inputs.project }}"
            echo "- 启动命令: ${{ inputs.start_cmd }}"
            
            # 切换到项目目录
            cd ${{ inputs.apps_root }}/${{ inputs.project }}
            echo "📁 当前目录: $(pwd)"
            
            # 验证项目目录是否存在
            if [ ! -d "${{ inputs.apps_root }}/${{ inputs.project }}" ]; then
              echo "🚨 项目目录不存在: ${{ inputs.apps_root }}/${{ inputs.project }}"
              exit 1
            fi
            
            # 验证项目目录不为空
            FILE_COUNT=$(find "${{ inputs.apps_root }}/${{ inputs.project }}" -type f | wc -l)
            if [ "$FILE_COUNT" -eq 0 ]; then
              echo "🚨 项目目录为空: ${{ inputs.apps_root }}/${{ inputs.project }}"
              exit 1
            fi
            
            echo "✅ 项目目录验证通过，文件数量: $FILE_COUNT"
            
            # 检查启动命令是否存在
            START_CMD="${{ inputs.start_cmd }}"
            CMD_NAME=$(echo "$START_CMD" | awk '{print $1}')
            
            # 检查是否有 ecosystem.config.js 文件（PM2 项目）
            if [ -f "ecosystem.config.js" ]; then
              echo "📋 发现 PM2 配置文件，使用 PM2 启动..."
              
              # 检查 PM2 是否安装
              if ! command -v pm2 &> /dev/null; then
                echo "🚨 PM2 未安装，尝试安装..."
                npm install -g pm2 || echo "PM2 安装失败"
              fi
              
              # 停止现有进程（如果存在）
              pm2 stop dashboard-backend 2>/dev/null || echo "没有现有进程需要停止"
              pm2 delete dashboard-backend 2>/dev/null || echo "没有现有进程需要删除"
              
              # 使用 PM2 启动
              echo "📋 使用 PM2 启动服务..."
              pm2 start ecosystem.config.js
              
              # 保存 PM2 配置
              pm2 save
              
              echo "✅ PM2 启动命令执行完成"
              START_PID=$(pm2 pid dashboard-backend 2>/dev/null || echo "0")
            else
              # 传统启动方式
              if ! command -v "$CMD_NAME" &> /dev/null; then
                echo "⚠️ 启动命令不存在: $CMD_NAME"
                echo "🔍 尝试查找可执行文件..."
                which "$CMD_NAME" || echo "未找到可执行文件"
              fi
              
              # 执行启动命令
              echo "📋 执行启动命令: $START_CMD"
              $START_CMD &
              START_PID=$!
            fi
            
            # 等待服务启动
            echo "⏳ 等待服务启动..."
            sleep 5
            
            # 检查进程是否还在运行
            if kill -0 $START_PID 2>/dev/null; then
              echo "✅ 启动命令执行成功，进程ID: $START_PID"
            else
              echo "⚠️ 启动命令可能已结束，检查服务状态..."
            fi
            
            # 检查服务状态（如果可能）
            echo "📋 检查服务状态..."
            if command -v systemctl &> /dev/null; then
              SERVICE_NAME="${{ inputs.project }}"
              if systemctl is-active --quiet $SERVICE_NAME; then
                echo "✅ 服务 $SERVICE_NAME 正在运行"
              else
                echo "⚠️ 服务 $SERVICE_NAME 未运行或无法检查"
                # 尝试检查进程
                if pgrep -f "${{ inputs.project }}" > /dev/null; then
                  echo "✅ 找到相关进程:"
                  pgrep -f "${{ inputs.project }}" | head -5
                else
                  echo "⚠️ 未找到相关进程"
                fi
              fi
            else
              echo "⚠️ 无法检查服务状态（systemctl不可用）"
              # 尝试检查进程
              if pgrep -f "${{ inputs.project }}" > /dev/null; then
                echo "✅ 找到相关进程:"
                pgrep -f "${{ inputs.project }}" | head -5
              else
                echo "⚠️ 未找到相关进程"
              fi
            fi
            
            # 检查端口是否被占用（如果是后端服务）
            if command -v netstat &> /dev/null; then
              echo "🔍 检查端口占用情况..."
              netstat -tlnp | grep -E ":(8080|3000|8000|5000)" | head -5 || echo "未找到相关端口"
            fi
            
            echo "✅ 启动命令执行完成"
            
            # 服务启动验证
            echo "🔍 开始服务启动验证..."
            
            # 等待更长时间确保服务完全启动
            echo "⏳ 等待服务完全启动..."
            sleep 10
            
            # 检查服务健康状态
            echo "🏥 检查服务健康状态..."
            if command -v curl &> /dev/null; then
              # 尝试访问健康检查端点
              for port in 8080 3000 8000 5000; do
                if curl -f -s http://localhost:$port/health > /dev/null 2>&1; then
                  echo "✅ 服务在端口 $port 上响应健康检查"
                  break
                elif curl -f -s http://localhost:$port/ > /dev/null 2>&1; then
                  echo "✅ 服务在端口 $port 上响应"
                  break
                fi
              done
            fi
            
            # 最终状态检查
            if pgrep -f "${{ inputs.project }}" > /dev/null || pm2 list | grep -q "${{ inputs.project }}"; then
              echo "✅ 服务启动成功！"
            else
              echo "⚠️ 服务可能未正常启动，但启动命令执行完成"
            fi
            
            echo "✅ 启动服务完成！"
            EOF
            
            # 使用SSH执行启动脚本
            ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 -o ServerAliveInterval=60 -o ServerAliveCountMax=3 -i /tmp/ssh_key -p ${{ inputs.server_port }} ${{ inputs.server_user }}@${{ inputs.server_host }} "bash -s" < /tmp/start_service_script.sh
          max_retries: 3
          retry_delay: 10
          timeout_minutes: 15
          retry_strategy: "exponential"
          continue_on_error: false
          notify_on_failure: true
          step_type: "network"
          env_vars: '{"SSH_KEY":"${{ inputs.server_key }}"}'

      - name: 设置输出
        id: set-outputs
        run: |
          echo "start_success=true" >> $GITHUB_OUTPUT
          echo "✅ 启动服务完成"
