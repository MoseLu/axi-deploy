name: Start Service

on:
  workflow_call:
    inputs:
      project:
        required: true
        type: string
        description: "项目名称"
      start_cmd:
        required: false
        type: string
        description: "启动命令"
        default: ""
      deploy_type:
        required: true
        type: string
        description: "部署类型 (backend/static)"
        default: "static"
      server_host:
        required: true
        type: string
        description: "服务器地址"
      server_user:
        required: true
        type: string
        description: "服务器用户"
      server_key:
        required: true
        type: string
        description: "服务器密钥"
      server_port:
        required: true
        type: string
        description: "服务器端口"
      apps_root:
        required: false
        type: string
        description: "应用目录路径"
        default: "/srv/apps"
      service_port:
        required: false
        type: string
        description: "服务端口（可选，默认从配置文件获取）"
        default: ""
    outputs:
      start_success:
        description: "启动是否成功"
        value: ${{ jobs.start.outputs.start_success }}

jobs:
  start:
    runs-on: ubuntu-latest
    timeout-minutes: 15  # 启动服务超时时间
    outputs:
      start_success: ${{ steps.set-outputs.outputs.start_success }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: 验证输入参数
        run: |
          echo "🔍 验证输入参数..."
          echo "- 项目: ${{ inputs.project }}"
          echo "- 部署类型: ${{ inputs.deploy_type }}"
          echo "- 启动命令: ${{ inputs.start_cmd }}"
          echo "- 服务器: ${{ inputs.server_host }}:${{ inputs.server_port }}"
          echo "- 用户: ${{ inputs.server_user }}"
          
          if [ "${{ inputs.deploy_type }}" != "backend" ]; then
            echo "⚠️ 非后端项目，跳过启动命令"
            echo "start_success=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          if [ -z "${{ inputs.start_cmd }}" ]; then
            echo "⚠️ 未提供启动命令，跳过启动步骤"
            echo "start_success=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "✅ 输入参数验证通过"

      - name: 创建SSH密钥文件
        run: |
          echo '${{ inputs.server_key }}' > /tmp/ssh_key
          chmod 600 /tmp/ssh_key

      - name: 获取服务端口
        id: get-port
        run: |
          PROJECT_NAME="${{ inputs.project }}"
          echo "🔍 获取项目端口配置..."
          
          # 方法1: 优先从服务器动态端口配置文件获取端口
          if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 -i /tmp/ssh_key -p ${{ inputs.server_port }} ${{ inputs.server_user }}@${{ inputs.server_host }} '[ -f "/srv/port-config.yml" ]' 2>/dev/null; then
            SERVICE_PORT=$(ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 -i /tmp/ssh_key -p ${{ inputs.server_port }} ${{ inputs.server_user }}@${{ inputs.server_host }} "grep -A 1 '^  $PROJECT_NAME:' /srv/port-config.yml | grep 'port:' | awk '{print \$2}'" 2>/dev/null)
            if [ -n "$SERVICE_PORT" ]; then
              echo "✅ 从服务器动态端口配置获取端口: $SERVICE_PORT"
            else
              echo "⚠️ 项目 '$PROJECT_NAME' 在服务器端口配置中未找到，尝试其他方法"
            fi
          fi
          
          # 方法2: 从输入参数获取端口
          if [ -z "$SERVICE_PORT" ] && [ ! -z "${{ inputs.service_port }}" ]; then
            SERVICE_PORT="${{ inputs.service_port }}"
            echo "✅ 从输入参数获取端口: $SERVICE_PORT"
          # 方法3: 从本地端口配置文件获取端口
          elif [ -f "port-config.yml" ]; then
            SERVICE_PORT=$(grep -A 1 "^  $PROJECT_NAME:" port-config.yml | grep "port:" | awk '{print $2}')
            if [ -z "$SERVICE_PORT" ]; then
              echo "⚠️ 项目 '$PROJECT_NAME' 在本地端口配置中未找到，使用默认端口8080"
              SERVICE_PORT="8080"
            else
              echo "✅ 从本地配置文件获取端口: $SERVICE_PORT"
            fi
          # 方法4: 使用默认端口
          else
            echo "⚠️ 端口配置文件不存在，使用默认端口8080"
            SERVICE_PORT="8080"
          fi
          
          echo "service_port=$SERVICE_PORT" >> $GITHUB_OUTPUT

      - name: 动态端口检查和分配
        id: port-allocation
        run: |
          PROJECT_NAME="${{ inputs.project }}"
          CURRENT_PORT="${{ steps.get-port.outputs.service_port }}"
          
          echo "🔧 动态端口检查和分配..."
          echo "- 项目: $PROJECT_NAME"
          echo "- 当前端口: $CURRENT_PORT"
          
          # 上传动态端口分配脚本到服务器
          echo "📤 上传动态端口分配脚本..."
          scp -o StrictHostKeyChecking=no -o ConnectTimeout=10 -i /tmp/ssh_key -P ${{ inputs.server_port }} scripts/dynamic-port-allocator.sh ${{ inputs.server_user }}@${{ inputs.server_host }}:/tmp/
          
          # 在服务器上执行端口检查和分配
          ALLOCATION_RESULT=$(ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 -i /tmp/ssh_key -p ${{ inputs.server_port }} ${{ inputs.server_user }}@${{ inputs.server_host }} "
            chmod +x /tmp/dynamic-port-allocator.sh
            
            # 检查当前端口是否可用
            if /tmp/dynamic-port-allocator.sh check '$PROJECT_NAME' 2>/dev/null; then
              echo 'PORT_AVAILABLE'
            else
              echo 'PORT_CONFLICT'
              # 重新分配端口
              NEW_PORT=\$(/tmp/dynamic-port-allocator.sh allocate '$PROJECT_NAME' '$CURRENT_PORT' 2>/dev/null)
              if [ -n \"\$NEW_PORT\" ]; then
                echo \"NEW_PORT:\$NEW_PORT\"
              else
                echo 'ALLOCATION_FAILED'
              fi
            fi
          " 2>/dev/null || echo "SSH_FAILED")
          
          if echo "$ALLOCATION_RESULT" | grep -q "PORT_AVAILABLE"; then
            echo "✅ 端口 $CURRENT_PORT 可用"
            echo "allocated_port=$CURRENT_PORT" >> $GITHUB_OUTPUT
            echo "port_status=available" >> $GITHUB_OUTPUT
          elif echo "$ALLOCATION_RESULT" | grep -q "NEW_PORT:"; then
            NEW_PORT=$(echo "$ALLOCATION_RESULT" | grep "NEW_PORT:" | cut -d':' -f2)
            echo "✅ 端口冲突已解决，新分配端口: $NEW_PORT"
            echo "allocated_port=$NEW_PORT" >> $GITHUB_OUTPUT
            echo "port_status=reallocated" >> $GITHUB_OUTPUT
          elif echo "$ALLOCATION_RESULT" | grep -q "ALLOCATION_FAILED"; then
            echo "❌ 端口分配失败"
            echo "allocated_port=$CURRENT_PORT" >> $GITHUB_OUTPUT
            echo "port_status=failed" >> $GITHUB_OUTPUT
          else
            echo "⚠️ 端口检查失败，使用原端口"
            echo "allocated_port=$CURRENT_PORT" >> $GITHUB_OUTPUT
            echo "port_status=unknown" >> $GITHUB_OUTPUT
          fi

      - name: 检查项目目录
        run: |
          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 -i /tmp/ssh_key -p ${{ inputs.server_port }} ${{ inputs.server_user }}@${{ inputs.server_host }} "
            cd ${{ inputs.apps_root }}/${{ inputs.project }}
            echo \"📁 当前目录: \$(pwd)\"
            
            if [ ! -d \"${{ inputs.apps_root }}/${{ inputs.project }}\" ]; then
              echo \"🚨 项目目录不存在: ${{ inputs.apps_root }}/${{ inputs.project }}\"
              exit 1
            fi
            
            FILE_COUNT=\$(find \"${{ inputs.apps_root }}/${{ inputs.project }}\" -type f | wc -l)
            if [ \"\$FILE_COUNT\" -eq 0 ]; then
              echo \"🚨 项目目录为空: ${{ inputs.apps_root }}/${{ inputs.project }}\"
              exit 1
            fi
            
            echo \"✅ 项目目录验证通过，文件数量: \$FILE_COUNT\"
          "

      - name: 检查MySQL服务
        run: |
          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 -i /tmp/ssh_key -p ${{ inputs.server_port }} ${{ inputs.server_user }}@${{ inputs.server_host }} "
            echo \"🔧 检查 MySQL 服务状态...\"
            
            if ! systemctl is-active --quiet mysql; then
              echo \"❌ MySQL 服务未运行，尝试启动...\"
              sudo systemctl start mysql
              sleep 5
            fi
            
            if systemctl is-active --quiet mysql; then
              echo \"✅ MySQL 服务已启动\"
              
              if mysql -u root -p123456 -e \"SELECT 1;\" 2>/dev/null; then
                echo \"✅ MySQL 连接成功\"
              else
                echo \"⚠️ MySQL 连接失败，尝试重启...\"
                sudo systemctl restart mysql
                sleep 10
                
                if mysql -u root -p123456 -e \"SELECT 1;\" 2>/dev/null; then
                  echo \"✅ MySQL 重启后连接成功\"
                else
                  echo \"❌ MySQL 连接仍然失败，但继续执行...\"
                fi
              fi
            else
              echo \"❌ MySQL 服务启动失败\"
            fi
          "

      - name: 修复服务配置
        run: |
          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 -i /tmp/ssh_key -p ${{ inputs.server_port }} ${{ inputs.server_user }}@${{ inputs.server_host }} "
            cd ${{ inputs.apps_root }}/${{ inputs.project }}
            
            # 修复服务文件
            SERVICE_FILE=\"${{ inputs.apps_root }}/${{ inputs.project }}/star-cloud.service\"
            if [ -f \"\$SERVICE_FILE\" ]; then
              # 使用动态分配的端口
              DYNAMIC_PORT=\"${{ steps.port-allocation.outputs.allocated_port }}\"
              if ! grep -q \"SERVICE_PORT=\$DYNAMIC_PORT\" \"\$SERVICE_FILE\"; then
                echo \"🔧 修复服务文件，添加 SERVICE_PORT 环境变量...\"
                sudo cp \"\$SERVICE_FILE\" \"\$SERVICE_FILE.backup.\$(date +%Y%m%d_%H%M%S)\"
                # 先删除旧的SERVICE_PORT配置（如果存在）
                sudo sed -i '/Environment=SERVICE_PORT=/d' \"\$SERVICE_FILE\"
                # 添加新的SERVICE_PORT配置
                sudo sed -i '/Environment=GIN_MODE=release/a Environment=SERVICE_PORT=\$DYNAMIC_PORT' \"\$SERVICE_FILE\"
                echo \"✅ 服务文件已更新，端口: \$DYNAMIC_PORT\"
              fi
            fi
            
            # 修复配置文件
            CONFIG_FILE=\"${{ inputs.apps_root }}/${{ inputs.project }}/backend/config/config-prod.yaml\"
            if [ -f \"\$CONFIG_FILE\" ]; then
              # 使用动态分配的端口
              DYNAMIC_PORT=\"${{ steps.port-allocation.outputs.allocated_port }}\"
              if ! grep -q \"port: '\$DYNAMIC_PORT'\" \"\$CONFIG_FILE\"; then
                echo \"🔧 修复配置文件，更新端口为 \$DYNAMIC_PORT...\"
                sudo cp \"\$CONFIG_FILE\" \"\$CONFIG_FILE.backup.\$(date +%Y%m%d_%H%M%S)\"
                # 更新端口配置，支持多种格式
                sudo sed -i \"s/port: '[0-9]*'/port: '\$DYNAMIC_PORT'/\" \"\$CONFIG_FILE\"
                sudo sed -i \"s/port: [0-9]*/port: \$DYNAMIC_PORT/\" \"\$CONFIG_FILE\"
                echo \"✅ 配置文件已更新，端口: \$DYNAMIC_PORT\"
              fi
            fi
            
            # 重新加载 systemd 配置
            sudo systemctl daemon-reload
          "

      - name: 更新Nginx配置
        id: update-nginx
        run: |
          PROJECT_NAME="${{ inputs.project }}"
          ALLOCATED_PORT="${{ steps.port-allocation.outputs.allocated_port }}"
          PORT_STATUS="${{ steps.port-allocation.outputs.port_status }}"
          
          echo "🔧 更新Nginx配置..."
          echo "- 项目: $PROJECT_NAME"
          echo "- 分配端口: $ALLOCATED_PORT"
          echo "- 端口状态: $PORT_STATUS"
          
          # 只有在端口重新分配时才更新Nginx配置
          if [ "$PORT_STATUS" = "reallocated" ]; then
            echo "📤 上传Nginx配置更新脚本..."
            scp -o StrictHostKeyChecking=no -o ConnectTimeout=10 -i /tmp/ssh_key -P ${{ inputs.server_port }} scripts/update-nginx-config.sh ${{ inputs.server_user }}@${{ inputs.server_host }}:/tmp/
            
            # 在服务器上执行Nginx配置更新
            NGINX_UPDATE_RESULT=$(ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 -i /tmp/ssh_key -p ${{ inputs.server_port }} ${{ inputs.server_user }}@${{ inputs.server_host }} "
              chmod +x /tmp/update-nginx-config.sh
              
              if /tmp/update-nginx-config.sh update '$PROJECT_NAME' '$ALLOCATED_PORT' 2>/dev/null; then
                echo 'NGINX_UPDATE_SUCCESS'
              else
                echo 'NGINX_UPDATE_FAILED'
              fi
            " 2>/dev/null || echo "SSH_FAILED")
            
            if echo "$NGINX_UPDATE_RESULT" | grep -q "NGINX_UPDATE_SUCCESS"; then
              echo "✅ Nginx配置更新成功"
              echo "nginx_updated=true" >> $GITHUB_OUTPUT
            else
              echo "❌ Nginx配置更新失败"
              echo "nginx_updated=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "ℹ️ 端口未重新分配，跳过Nginx配置更新"
            echo "nginx_updated=true" >> $GITHUB_OUTPUT
          fi

      - name: 执行启动命令
        id: start-service
        run: |
          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 -o ServerAliveInterval=60 -o ServerAliveCountMax=3 -i /tmp/ssh_key -p ${{ inputs.server_port }} ${{ inputs.server_user }}@${{ inputs.server_host }} "
            cd ${{ inputs.apps_root }}/${{ inputs.project }}
            
            echo \"🚀 执行启动命令...\"
            echo \"- 项目: ${{ inputs.project }}\"
            echo \"- 启动命令: ${{ inputs.start_cmd }}\"
            echo \"- 服务端口: ${{ steps.port-allocation.outputs.allocated_port }}\"
            
            # 检查启动脚本
            if [ -f \"start-simple.sh\" ]; then
              echo \"📋 使用简化启动脚本...\"
              chmod +x start-simple.sh
              SERVICE_PORT=\"${{ steps.port-allocation.outputs.allocated_port }}\" ./start-simple.sh
            elif [ -f \"start.sh\" ]; then
              echo \"📋 使用启动脚本...\"
              chmod +x start.sh
              ./start.sh
            elif [ -f \"ecosystem.config.js\" ]; then
              echo \"📋 使用 PM2 启动...\"
              if ! command -v pm2 &> /dev/null; then
                npm install -g pm2
              fi
              if [ ! -d \"node_modules\" ]; then
                if command -v pnpm &> /dev/null; then
                  pnpm install --prod --no-frozen-lockfile
                else
                  npm install --production
                fi
              fi
              pm2 stop dashboard-backend 2>/dev/null || true
              pm2 delete dashboard-backend 2>/dev/null || true
              pm2 start ecosystem.config.js
              pm2 save
            else
              echo \"📋 执行直接启动命令...\"
              ${{ inputs.start_cmd }} &
            fi
            
            echo \"✅ 启动命令执行完成\"
          "

      - name: 验证服务启动
        id: validate-service
        run: |
          SERVICE_PORT="${{ steps.port-allocation.outputs.allocated_port }}"
          echo "🔍 验证服务启动..."
          echo "- 服务端口: $SERVICE_PORT"
          
          # 等待服务启动
          sleep 10
          
          # 验证服务是否响应
          VALIDATION_SUCCESS=false
          for i in {1..6}; do
            echo "🔍 验证尝试 $i/6..."
            
            VALIDATION_RESULT=$(ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 -i /tmp/ssh_key -p ${{ inputs.server_port }} ${{ inputs.server_user }}@${{ inputs.server_host }} "
              if netstat -tlnp 2>/dev/null | grep -q ':$SERVICE_PORT'; then
                echo 'PORT_LISTENING'
                HEALTH_RESPONSE=\$(curl -s -o /dev/null -w '%{http_code}' 'http://localhost:$SERVICE_PORT/health' --connect-timeout 5 --max-time 10 2>/dev/null || echo 'connection_failed')
                if [ \"\$HEALTH_RESPONSE\" = \"200\" ]; then
                  echo 'HEALTH_SUCCESS'
                else
                  echo 'HEALTH_FAILED:\$HEALTH_RESPONSE'
                fi
              else
                echo 'PORT_NOT_LISTENING'
              fi
            " 2>/dev/null || echo "SSH_FAILED")
            
            if echo "$VALIDATION_RESULT" | grep -q "PORT_LISTENING"; then
              echo "✅ 端口 $SERVICE_PORT 正在监听"
              
              if echo "$VALIDATION_RESULT" | grep -q "HEALTH_SUCCESS"; then
                echo "✅ 健康检查成功"
                VALIDATION_SUCCESS=true
                break
              else
                HEALTH_CODE=$(echo "$VALIDATION_RESULT" | grep "HEALTH_FAILED" | cut -d':' -f2)
                echo "❌ 健康检查失败 - 响应: $HEALTH_CODE"
              fi
            else
              echo "❌ 端口 $SERVICE_PORT 未监听"
            fi
            
            if [ $i -lt 6 ]; then
              echo "⏳ 等待 5 秒后重试验证..."
              sleep 5
            fi
          done
          
          if [ "$VALIDATION_SUCCESS" = "true" ]; then
            echo "success=true" >> $GITHUB_OUTPUT
            echo "✅ 服务验证成功！"
          else
            echo "success=false" >> $GITHUB_OUTPUT
            echo "❌ 服务验证失败"
            exit 1
          fi

      - name: 设置输出
        id: set-outputs
        run: |
          if [ "${{ steps.validate-service.outputs.success }}" = "true" ]; then
            echo "start_success=true" >> $GITHUB_OUTPUT
            echo "✅ 启动服务成功"
          else
            echo "start_success=false" >> $GITHUB_OUTPUT
            echo "❌ 启动服务失败"
            exit 1
          fi
