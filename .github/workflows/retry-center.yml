name: Retry Center Workflow

description: "重试中心可复用工作流 - 统一管理 GitHub Actions 工作流中的重试机制"

on:
  workflow_call:
    inputs:
      # 重试配置
      max_retries:
        description: '最大重试次数'
        required: false
        type: number
        default: 3
      retry_delay:
        description: '重试间隔（秒）'
        required: false
        type: number
        default: 5
      timeout_minutes:
        description: '单次执行超时时间（分钟）'
        required: false
        type: number
        default: 10
      
      # 重试策略
      retry_strategy:
        description: '重试策略 (simple/exponential/adaptive)'
        required: false
        type: string
        default: 'simple'
      
      # 执行配置
      step_name:
        description: '步骤名称（用于日志和跟踪）'
        required: true
        type: string
      command:
        description: '要执行的命令'
        required: true
        type: string
      
      # 错误处理
      continue_on_error:
        description: '重试失败后是否继续执行'
        required: false
        type: boolean
        default: false
      
      # 通知配置
      notify_on_failure:
        description: '失败时是否发送通知'
        required: false
        type: boolean
        default: true
      
      # 步骤类型配置
      step_type:
        description: '步骤类型 (network/file_operation/validation/parsing/backend_service)'
        required: false
        type: string
        default: 'network'
      
      # 环境变量
      env_vars:
        description: '环境变量（JSON格式）'
        required: false
        type: string
        default: '{}'
      
      # 新增：后端服务诊断配置
      backend_diagnosis:
        description: '是否启用后端服务诊断'
        required: false
        type: boolean
        default: false
      
      # 新增：服务重启配置
      restart_service:
        description: '失败时是否尝试重启服务'
        required: false
        type: boolean
        default: false
      
      # 新增：服务验证配置
      service_validation:
        description: '是否启用服务验证'
        required: false
        type: boolean
        default: false
      
      # 新增：服务端口配置
      service_port:
        description: '服务端口（用于验证）'
        required: false
        type: string
        default: ''
      
      # 新增：健康检查端点
      health_endpoint:
        description: '健康检查端点'
        required: false
        type: string
        default: '/health'
      
      # 新增：验证超时时间
      validation_timeout:
        description: '验证超时时间（秒）'
        required: false
        type: number
        default: 30

    outputs:
      success:
        description: '执行是否成功'
        value: ${{ jobs.retry-execution.outputs.success }}
      attempts:
        description: '实际重试次数'
        value: ${{ jobs.retry-execution.outputs.attempts }}
      execution_time:
        description: '总执行时间（秒）'
        value: ${{ jobs.retry-execution.outputs.execution_time }}
      error_message:
        description: '错误信息（如果失败）'
        value: ${{ jobs.retry-execution.outputs.error_message }}
      retry_report:
        description: '重试报告（JSON格式）'
        value: ${{ jobs.retry-execution.outputs.retry_report }}

jobs:
  retry-execution:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    outputs:
      success: ${{ steps.retry-step.outputs.success }}
      attempts: ${{ steps.retry-step.outputs.attempts }}
      execution_time: ${{ steps.retry-step.outputs.execution_time }}
      error_message: ${{ steps.retry-step.outputs.error_message }}
      retry_report: ${{ steps.retry-step.outputs.retry_report }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: 解析环境变量
        id: parse-env
        run: |
          echo "🔍 解析环境变量..."
          
          # 解析JSON格式的环境变量
          ENV_VARS='${{ inputs.env_vars }}'
          if [ "$ENV_VARS" != "{}" ]; then
            echo "📋 环境变量:"
            echo "$ENV_VARS" | jq -r 'to_entries[] | "export \(.key)=\(.value)"'
          else
            echo "📋 无自定义环境变量"
          fi
          
          echo "env_vars_parsed=true" >> $GITHUB_OUTPUT

      - name: 执行重试逻辑
        id: retry-step
        shell: bash
        run: |
          # 重试中心核心逻辑
          MAX_RETRIES=${{ inputs.max_retries }}
          RETRY_DELAY=${{ inputs.retry_delay }}
          TIMEOUT_MINUTES=${{ inputs.timeout_minutes }}
          STRATEGY="${{ inputs.retry_strategy }}"
          STEP_NAME="${{ inputs.step_name }}"
          COMMAND="${{ inputs.command }}"
          CONTINUE_ON_ERROR="${{ inputs.continue_on_error }}"
          NOTIFY_ON_FAILURE="${{ inputs.notify_on_failure }}"
          STEP_TYPE="${{ inputs.step_type }}"
          
          # 初始化变量
          ATTEMPTS=0
          SUCCESS=false
          ERROR_MESSAGE=""
          START_TIME=$(date +%s)
          
          echo "🚀 开始执行重试逻辑"
          echo "步骤名称: $STEP_NAME"
          echo "最大重试次数: $MAX_RETRIES"
          echo "重试间隔: $RETRY_DELAY秒"
          echo "超时时间: $TIMEOUT_MINUTES分钟"
          echo "重试策略: $STRATEGY"
          echo "步骤类型: $STEP_TYPE"
          
          # 重试逻辑
          while [ $ATTEMPTS -le $MAX_RETRIES ]; do
            ATTEMPTS=$((ATTEMPTS + 1))
            echo ""
            echo "🔄 第 $ATTEMPTS 次尝试执行..."
            
            # 设置超时
            TIMEOUT_CMD="timeout ${TIMEOUT_MINUTES}m"
            
            # 执行命令
            if $TIMEOUT_CMD bash -c "$COMMAND"; then
              echo "✅ 命令执行成功！"
              
              # 如果启用了服务验证，进行服务验证
              if [ "${{ inputs.service_validation }}" = "true" ] && [ -n "${{ inputs.service_port }}" ]; then
                echo "🔍 开始服务验证..."
                echo "- 服务端口: ${{ inputs.service_port }}"
                echo "- 健康检查端点: ${{ inputs.health_endpoint }}"
                echo "- 验证超时: ${{ inputs.validation_timeout }}秒"
                
                # 等待服务启动
                echo "⏳ 等待服务启动..."
                sleep 5
                
                # 验证服务是否响应
                VALIDATION_SUCCESS=false
                VALIDATION_ATTEMPTS=0
                MAX_VALIDATION_ATTEMPTS=6
                
                while [ $VALIDATION_ATTEMPTS -lt $MAX_VALIDATION_ATTEMPTS ]; do
                  VALIDATION_ATTEMPTS=$((VALIDATION_ATTEMPTS + 1))
                  echo "🔍 验证尝试 $VALIDATION_ATTEMPTS/$MAX_VALIDATION_ATTEMPTS..."
                  
                  # 检查端口是否监听
                  if netstat -tlnp 2>/dev/null | grep -q ":${{ inputs.service_port }}"; then
                    echo "✅ 端口 ${{ inputs.service_port }} 正在监听"
                    
                    # 测试健康检查端点
                    HEALTH_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "http://localhost:${{ inputs.service_port }}${{ inputs.health_endpoint }}" --connect-timeout 5 --max-time 10 2>/dev/null || echo "connection_failed")
                    
                    if [ "$HEALTH_RESPONSE" = "200" ]; then
                      echo "✅ 健康检查成功 - 状态码: $HEALTH_RESPONSE"
                      VALIDATION_SUCCESS=true
                      break
                    else
                      echo "❌ 健康检查失败 - 响应: $HEALTH_RESPONSE"
                    fi
                  else
                    echo "❌ 端口 ${{ inputs.service_port }} 未监听"
                  fi
                  
                  # 如果不是最后一次验证，等待后重试
                  if [ $VALIDATION_ATTEMPTS -lt $MAX_VALIDATION_ATTEMPTS ]; then
                    echo "⏳ 等待 5 秒后重试验证..."
                    sleep 5
                  fi
                done
                
                if [ "$VALIDATION_SUCCESS" = "true" ]; then
                  echo "✅ 服务验证成功！"
                  SUCCESS=true
                  break
                else
                  echo "❌ 服务验证失败"
                  ERROR_MESSAGE="服务启动成功但验证失败 - 端口:${{ inputs.service_port }}, 健康检查:${{ inputs.health_endpoint }}"
                  SUCCESS=false
                fi
              else
                # 没有启用服务验证，直接认为成功
                SUCCESS=true
                break
              fi
            else
              EXIT_CODE=$?
              if [ $EXIT_CODE -eq 124 ]; then
                ERROR_MESSAGE="执行超时（${TIMEOUT_MINUTES}分钟）"
              else
                ERROR_MESSAGE="执行失败，退出码: $EXIT_CODE"
              fi
              
              echo "❌ 执行失败: $ERROR_MESSAGE"
              
              # 检查是否还有重试机会
              if [ $ATTEMPTS -le $MAX_RETRIES ]; then
                # 计算重试延迟
                if [ "$STRATEGY" = "exponential" ]; then
                  DELAY=$((RETRY_DELAY * (2 ** (ATTEMPTS - 1))))
                elif [ "$STRATEGY" = "adaptive" ]; then
                  DELAY=$((RETRY_DELAY + ATTEMPTS * 2))
                else
                  DELAY=$RETRY_DELAY
                fi
                
                echo "⏳ 等待 $DELAY 秒后重试..."
                sleep $DELAY
              fi
            fi
          done
          
          # 计算执行时间
          END_TIME=$(date +%s)
          EXECUTION_TIME=$((END_TIME - START_TIME))
          
          # 设置输出
          echo "success=$SUCCESS" >> $GITHUB_OUTPUT
          echo "attempts=$ATTEMPTS" >> $GITHUB_OUTPUT
          echo "execution_time=$EXECUTION_TIME" >> $GITHUB_OUTPUT
          echo "error_message=$ERROR_MESSAGE" >> $GITHUB_OUTPUT
          
          # 生成重试报告
          RETRY_REPORT=$(cat << EOF
          {
            "step_name": "$STEP_NAME",
            "workflow_run_id": "${{ github.run_id }}",
            "job_name": "retry-execution",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "success": $SUCCESS,
            "attempts": $ATTEMPTS,
            "execution_time_seconds": $EXECUTION_TIME,
            "error_message": "$ERROR_MESSAGE",
            "retry_config": {
              "max_retries": $MAX_RETRIES,
              "retry_delay": $RETRY_DELAY,
              "timeout_minutes": $TIMEOUT_MINUTES,
              "strategy": "$STRATEGY",
              "step_type": "$STEP_TYPE"
            },
            "environment": {
              "runner": "${{ runner.os }}",
              "workflow": "${{ github.workflow }}",
              "repository": "${{ github.repository }}"
            }
          }
          EOF
          )
          
          echo "retry_report='$RETRY_REPORT'" >> $GITHUB_OUTPUT
          
          # 最终结果
          if [ "$SUCCESS" = "true" ]; then
            echo "🎉 重试逻辑执行完成 - 成功"
          else
            echo "💥 重试逻辑执行完成 - 失败"
            if [ "$CONTINUE_ON_ERROR" = "false" ]; then
              exit 1
            fi
          fi

      - name: 生成重试报告文件
        if: always()
        run: |
          echo "📊 生成重试报告文件..."
          
          # 创建报告目录
          mkdir -p .github/retry-reports
          
          # 生成报告文件名
          REPORT_FILE=".github/retry-reports/retry-report-$(date +%Y%m%d_%H%M%S).json"
          
          # 写入报告内容
          echo '${{ steps.retry-step.outputs.retry_report }}' > "$REPORT_FILE"
          
          echo "✅ 重试报告已生成: $REPORT_FILE"
          
          # 输出报告内容
          cat "$REPORT_FILE"

      - name: 上传重试报告
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: retry-reports-${{ github.run_id }}
          path: .github/retry-reports/
          retention-days: 30

      - name: 失败通知
        if: failure() && inputs.notify_on_failure == 'true'
        run: |
          echo "📢 重试失败通知"
          echo "=================="
          echo "步骤名称: ${{ inputs.step_name }}"
          echo "工作流运行ID: ${{ github.run_id }}"
          echo "重试次数: ${{ steps.retry-step.outputs.attempts || '0' }}"
          echo "执行时间: ${{ steps.retry-step.outputs.execution_time || '0' }}秒"
          echo "错误信息: ${{ steps.retry-step.outputs.error_message || '未知错误' }}"
          echo ""
          echo "🔍 请检查重试报告了解详细信息"
          
          # 这里可以集成Slack、Email等通知服务
          # 例如：curl -X POST -H 'Content-type: application/json' --data '{"text":"重试失败通知"}' $SLACK_WEBHOOK_URL
